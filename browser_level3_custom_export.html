<!DOCTYPE html>
<html>
<head>
    <title>Level 3 Custom Data Export</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        .export-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 600px;
            text-align: center;
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        
        .input-group {
            margin-bottom: 25px;
        }
        
        input, select {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            box-sizing: border-box;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        input:focus, select:focus {
            border-color: #4CAF50;
            outline: none;
        }
        
        button {
            background: #4CAF50;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
            margin: 10px 5px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        
        .error {
            color: #ff0000;
            font-size: 14px;
            margin-top: 5px;
            display: none;
        }
        
        .loading {
            display: none;
            margin-top: 10px;
            color: #666;
        }
        
        .success {
            color: #4CAF50;
            font-size: 14px;
            margin-top: 15px;
            display: none;
        }
        
        .data-preview {
            margin-top: 20px;
            text-align: left;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 6px;
            background: #f9f9f9;
            display: none;
        }
        
        .preview-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .preview-table th, .preview-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
            font-size: 12px;
        }
        
        .preview-table th {
            background-color: #f2f2f2;
        }
        
        .button-group {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        
        .home-button {
            background: #666;
            margin-top: 20px;
        }
        
        .home-button:hover {
            background: #555;
        }
        
        .shortcut-info {
            margin-top: 20px;
            font-size: 12px;
            color: #666;
        }
        
        .level-badge {
            display: inline-block;
            background-color: #f8c291;
            color: #333;
            border-radius: 15px;
            padding: 5px 15px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        
        /* Environment type styling */
        .env-r, .env-R {
            background-color: rgba(200, 230, 255, 0.3) !important; /* Light blue for Rough environments */
        }
        
        .env-s, .env-S {
            background-color: rgba(255, 200, 200, 0.3) !important; /* Light red for Smooth environments */
        }
        
        .env-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: bold;
            margin-left: 5px;
        }
        
        .env-legend {
            margin: 10px 0;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="export-container">
        <h1>Level 3 Custom Data Export</h1>
        <div class="level-badge">LEVEL 3 ONLY</div>
        <div class="shortcut-info">Access this page with Ctrl+W (Windows) or Cmd+W (Mac)</div>
        
        <div style="margin-bottom: 20px; font-size: 14px; text-align: left; color: #555;">
            <p>This tool exports Level 3 data in the custom format for spatial search analysis with the following fields:</p>
            <ul style="padding-left: 20px;">
                <li><strong>"#":</strong> Row index</li>
                <li><strong>x,y:</strong> Tile coordinates (0-8)</li>
                <li><strong>z:</strong> Raw reward value</li>
                <li><strong>zscaled:</strong> Normalized reward value</li>
                <li><strong>trial:</strong> Trial number</li>
                <li><strong>block:</strong> Block/session number</li>
                <li><strong>monkeyid:</strong> The monkey's ID number</li>
                <li><strong>scale:</strong> Scaling factor</li>
                <li><strong>envOrder:</strong> Environment order number</li>
            </ul>
        </div>
        
        <div class="input-group">
            <label for="monkeyName">Enter Monkey Name</label>
            <input type="text" id="monkeyName" placeholder="Enter monkey name" autocomplete="off">
            <div id="error" class="error">Please enter a valid name</div>
        </div>
        
        <div id="tryNumberSelector" class="input-group" style="display: none;">
            <label for="tryNumber">Select Try Number</label>
            <select id="tryNumber">
                <option value="all">All Attempts</option>
                <!-- Options will be populated dynamically -->
            </select>
        </div>
        
        <div id="loading" class="loading">Fetching data...</div>
        <div id="success" class="success"></div>
        
        <div class="button-group">
            <button id="fetchButton">Fetch Level 3 Data</button>
            <button id="downloadButton" disabled>Download CSV</button>
            <button id="downloadJsonButton" disabled>Download JSON</button>
        </div>
        
        <div id="dataPreview" class="data-preview">
            <h3>Data Preview</h3>
            <div style="margin-bottom: 10px; font-size: 11px; color: #666;">
                Values for z, zscaled, and pellet_count are now stored consistently between exports.
            </div>
            <div id="previewContent"></div>
        </div>
        
        <button class="home-button" onclick="window.location.href='browser_game.html'">Return to Game</button>
    </div>

    <!-- SQL.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
    <script>
        // Initialize SQL.js
        let db;
        let SQL;
        let trialData = [];
        let availableTryNumbers = [];
        let kernelSmoothData = null; // Store KernelSmooth data
        
        // For debugging
        let lastError = null;
        
        // Add a debug function to help troubleshoot
        function debugLog(message, data) {
            console.log(`[DEBUG] ${message}`, data);
        }
        
        // Constants
        const MAX_TRIALS_LEVEL_3 = 26; // Total: 25 user-selected trials + 1 initial auto-revealed tile
        const MIN_TRIALS_LEVEL_3 = 26; // Ensure we always generate 26 entries
        const LEVEL = 3; // Only showing Level 3 data
        let currentEnvironment = "R"; // Default environment type
        
        // Load the KernelSmooth.json file for original experiment calculations
        async function loadKernelSmoothData() {
            try {
                const response = await fetch('/kernelSmooth.json');
                if (!response.ok) {
                    throw new Error(`Failed to load KernelSmooth.json: ${response.status}`);
                }
                
                const data = await response.json();
                debugLog("KernelSmooth.json loaded successfully", {
                    environmentCount: Object.keys(data).length
                });
                
                return data;
            } catch (error) {
                debugLog("Error loading KernelSmooth.json", error);
                // Return null on error to allow fallback
                return null;
            }
        }
        
        // Initialize KernelSmooth data asynchronously
        (async function() {
            kernelSmoothData = await loadKernelSmoothData();
        })();
        
        // Gaussian noise generator from original experiment
        function myNorm() {
            var x1, x2, rad, c;
            do {
                x1 = 2 * Math.random() - 1;
                x2 = 2 * Math.random() - 1;
                rad = x1 * x1 + x2 * x2;
            } while (rad >= 1 || rad == 0);
            c = Math.sqrt(-2 * Math.log(rad) / rad);
            return (x1 * c);
        };
        
        // Get a random subarray - used for environment selection in original experiment
        function getRandomSubarray(arr, size) {
            var shuffled = arr.slice(0),
                i = arr.length,
                temp, index;
            while (i--) {
                index = Math.floor((i + 1) * Math.random());
                temp = shuffled[index];
                shuffled[index] = shuffled[i];
                shuffled[i] = temp;
            }
            return shuffled.slice(0, size);
        }
        
        // Generate a random number in range - for scale calculation
        function randomNum(min, max) {
            return Math.floor(Math.random() * (max - min + 1) + min);
        }
        
        // SIMPLIFIED VERSION FOR RELIABLE VALUES

        // Constants for calculations
        const SCALE_MIN = 30;  // Min scale value in original experiment
        const SCALE_MAX = 40;  // Max scale value in original experiment
        
        // Generate a simplified scale factor (30-40 range)
        function calculateScale(tryNumber, monkeyName) {
            // Try to get previously stored scales for consistency
            try {
                // If no monkey name provided, use legacy storage
                if (!monkeyName) {
                    const storedScales = JSON.parse(localStorage.getItem('level3_scales') || '{}');
                    
                    // If we have a value for this try number, use it
                    if (storedScales[tryNumber]) {
                        console.log(`Using stored scale for try ${tryNumber}: ${storedScales[tryNumber]}`);
                        return storedScales[tryNumber];
                    }
                    
                    // Generate a new random scale between 30-40
                    const newScale = Math.floor(Math.random() * (SCALE_MAX - SCALE_MIN + 1)) + SCALE_MIN;
                    
                    // Store for consistency
                    storedScales[tryNumber] = newScale;
                    localStorage.setItem('level3_scales', JSON.stringify(storedScales));
                    
                    console.log(`Generated new scale for try ${tryNumber}: ${newScale}`);
                    return newScale;
                }
                
                // For monkey-specific storage
                const key = `level3_scales_${monkeyName}`;
                const storedScales = JSON.parse(localStorage.getItem(key) || '{}');
                
                // If we have a value for this try number, use it
                if (storedScales[tryNumber]) {
                    console.log(`Using stored scale for ${monkeyName} try ${tryNumber}: ${storedScales[tryNumber]}`);
                    return storedScales[tryNumber];
                }
                
                // Generate a new random scale between 30-40
                const newScale = Math.floor(Math.random() * (SCALE_MAX - SCALE_MIN + 1)) + SCALE_MIN;
                
                // Store for consistency
                storedScales[tryNumber] = newScale;
                localStorage.setItem(key, JSON.stringify(storedScales));
                
                console.log(`Generated new scale for ${monkeyName} try ${tryNumber}: ${newScale}`);
                return newScale;
            } catch (e) {
                console.error("Error managing scales:", e);
                // Fallback to deterministic value that's unique per monkey and try
                let hash = 0;
                if (monkeyName) {
                    for (let i = 0; i < monkeyName.length; i++) {
                        hash = ((hash << 5) - hash) + monkeyName.charCodeAt(i);
                        hash |= 0; // Convert to 32bit integer
                    }
                    return SCALE_MIN + ((tryNumber + hash) % 11);
                }
                // Original fallback
                return SCALE_MIN + (tryNumber % 11);
            }
        }
        
        // Full environment order selection (0-39) like original experiment
        function calculateEnvOrder(tryNumber, monkeyName) {
            // Try to get stored environment orders for consistency
            try {
                // If no monkey name provided, use legacy storage
                if (!monkeyName) {
                    const storedEnvs = JSON.parse(localStorage.getItem('level3_environments') || '{}');
                    
                    // If we have a value for this try number, use it
                    if (storedEnvs[tryNumber] !== undefined) {
                        console.log(`Using stored envOrder for try ${tryNumber}: ${storedEnvs[tryNumber]}`);
                        return storedEnvs[tryNumber];
                    }
                    
                    // Create the full range of environments (0-39) like original experiment
                    const fullEnvRange = Array.from({length: 40}, (_, i) => i); // [0, 1, 2, ..., 39]
                    
                    // Select a random environment from the full range using the getRandomSubarray function
                    // This matches the original experiment's approach
                    const newEnv = getRandomSubarray(fullEnvRange, 1)[0];
                    
                    // Store for consistency
                    storedEnvs[tryNumber] = newEnv;
                    localStorage.setItem('level3_environments', JSON.stringify(storedEnvs));
                    
                    console.log(`Generated new envOrder for try ${tryNumber}: ${newEnv}`);
                    return newEnv;
                }
                
                // For monkey-specific environment storage
                const key = `level3_environments_${monkeyName}`;
                const storedEnvs = JSON.parse(localStorage.getItem(key) || '{}');
                
                // If we have a value for this try number, use it
                if (storedEnvs[tryNumber] !== undefined) {
                    console.log(`Using stored envOrder for ${monkeyName} try ${tryNumber}: ${storedEnvs[tryNumber]}`);
                    return storedEnvs[tryNumber];
                }
                
                // Create the full range of environments (0-39) like original experiment
                const fullEnvRange = Array.from({length: 40}, (_, i) => i); // [0, 1, 2, ..., 39]
                
                // Select a random environment from the full range using the getRandomSubarray function
                // This matches the original experiment's approach
                const newEnv = getRandomSubarray(fullEnvRange, 1)[0];
                
                // Store for consistency
                storedEnvs[tryNumber] = newEnv;
                localStorage.setItem(key, JSON.stringify(storedEnvs));
                
                console.log(`Generated new envOrder for ${monkeyName} try ${tryNumber}: ${newEnv}`);
                return newEnv;
            } catch (e) {
                console.error("Error managing environments:", e);
                // Fallback to deterministic value that's unique per monkey and try
                // Create a simple hash from the monkey name to generate different values
                let hash = 0;
                if (monkeyName) {
                    for (let i = 0; i < monkeyName.length; i++) {
                        hash = ((hash << 5) - hash) + monkeyName.charCodeAt(i);
                        hash |= 0; // Convert to 32bit integer
                    }
                    return (tryNumber + hash) % 40; // Use modulo 40 to stay in 0-39 range
                }
                // Original fallback
                return tryNumber % 40;
            }
        }
        
        // Get the value from KernelSmooth.json for a specific cell
        // Updated to handle the full 0-39 environment range
        function getValueFromKernelSmooth(envIndex, x, y) {
            try {
                if (!kernelSmoothData) {
                    throw new Error("KernelSmooth data not available");
                }
                
                // Get available environments from the data
                const availableEnvs = Object.keys(kernelSmoothData).length;
                
                // Map the full 0-39 environment index to the available environments (likely 0-3)
                // This maintains backward compatibility with existing KernelSmooth.json
                // In the original experiment, the 40 environments were likely variations on base patterns
                
                // First determine if it's a Rough or Smooth environment
                // In original experiment, even indices are Rough, odd are Smooth
                const isRoughEnvironment = envIndex % 2 === 0;
                
                // Map to one of the available base environments while preserving R/S pattern
                // If we have 4 environments (0,1,2,3), even envIndex maps to 0 or 2, odd to 1 or 3
                const baseEnvCount = Math.floor(availableEnvs / 2); // Count of each type (R or S)
                
                // Determine which base environment to use within the R or S category
                // This distributes the 40 environments across the available base environments
                // while maintaining the R/S pattern
                const baseEnvOffset = Math.floor((envIndex / 2) % baseEnvCount);
                
                // Calculate final index: for Rough environments use 0, 2, 4..., for Smooth use 1, 3, 5...
                const actualEnvIndex = (isRoughEnvironment ? 0 : 1) + (baseEnvOffset * 2);
                
                // Make sure we stay within available environments
                const finalEnvIndex = actualEnvIndex % availableEnvs;
                
                // Get this environment's data
                const env = kernelSmoothData[finalEnvIndex.toString()];
                if (!env) {
                    throw new Error(`Environment ${finalEnvIndex} not found`);
                }
                
                // Find the cell in this environment with matching x,y
                const cellKey = Object.keys(env).find(key => {
                    const cell = env[key];
                    return parseInt(cell.x1) === x && parseInt(cell.x2) === y;
                });
                
                if (!cellKey) {
                    throw new Error(`Cell at position (${x},${y}) not found in environment ${finalEnvIndex}`);
                }
                
                // Get the y value (0-1 range) and convert to 0-50 range
                const value = env[cellKey].y * 50;
                console.log(`Found value ${value} for original env ${envIndex} (mapped to ${finalEnvIndex}), pos (${x},${y})`);
                
                return value;
            } catch (e) {
                console.warn("Error getting value from KernelSmooth:", e);
                
                // More sophisticated fallback that simulates the original experiment behavior
                // Uses the environment index to generate a deterministic but varied pattern
                const seed = envIndex * 1000 + x * 10 + y;
                const pseudoRandom = Math.sin(seed) * 10000;
                const normalizedValue = Math.abs(pseudoRandom - Math.floor(pseudoRandom));
                
                // Generate a value in 0-50 range with more variance based on environment type
                // Even (Rough) environments have more variance, Odd (Smooth) have less
                const baseValue = 25; // center point
                const varianceFactor = envIndex % 2 === 0 ? 20 : 10; // R=more variance, S=less variance
                return Math.round(baseValue + (normalizedValue - 0.5) * varianceFactor);
            }
        }
        
        // Generate a full cell using reliable methodology
        function generateCellValues(tryNumber, trial, monkeyName) {
            try {
                // Get environment type - 0,1,2,3 from kernelSmooth.json
                const envOrder = calculateEnvOrder(tryNumber, monkeyName);
                
                // Get scale factor - random in original experiment between 30-40
                const scale = calculateScale(tryNumber, monkeyName);
                
                // Calculate coordinates from trial number
                const x = (trial - 1) % 8;
                const y = Math.floor((trial - 1) / 8);
                
                // Get the base value from KernelSmooth.json
                const baseValue = getValueFromKernelSmooth(envOrder, x, y);
                
                // Add noise to the value (handling both legacy and monkey-specific cases)
                let noiseyValue;
                
                // Check if we're using monkey-specific noise
                if (monkeyName) {
                    // Create a monkey-specific seed for consistent randomization
                    let monkeySeed = 0;
                    for (let i = 0; i < monkeyName.length; i++) {
                        monkeySeed = ((monkeySeed << 5) - monkeySeed) + monkeyName.charCodeAt(i);
                        monkeySeed |= 0; // Convert to 32bit integer
                    }
                    
                    // Use the monkey name and trial/try as part of the seed for noise
                    // This ensures the same monkey gets the same noise for the same try/trial,
                    // but different monkeys get different noise patterns
                    const seedFactor = monkeySeed + (tryNumber * 100) + trial;
                    
                    // Deterministic noise based on monkey and trial 
                    const deterministicNoise = Math.sin(seedFactor) * 10; 
                    
                    // Combine deterministic noise with gaussian noise for more natural variation
                    // but still keeping it consistent for the same monkey/try/trial
                    const noiseFactor = (myNorm() * 2.5) + (deterministicNoise * 2.5);
                    
                    // Add noise
                    noiseyValue = Math.round(baseValue + noiseFactor);
                } else {
                    // Legacy approach - just add Gaussian noise
                    noiseyValue = Math.round(baseValue + myNorm() * 5);
                }
                
                // Calculate z value (0-1 range)
                const z = noiseyValue / 50;
                
                // Rescale the value, matching original experiment
                const rescaledValue = Math.max(Math.round(noiseyValue / 50 * scale + 5), 0);
                
                // Calculate zscaled exactly as in original: z * scale
                const zscaled = Math.round(z * scale);
                
                // Generate a pellet count based on rescaled value
                const pelletCount = Math.ceil(rescaledValue / 5);
                
                // For UI - determine if environment is "R" (rough) or "S" (smooth)
                // In the original experiment: even indices (0,2,4,...38) are Rough environments
                // Odd indices (1,3,5,...39) are Smooth environments
                const environmentType = (envOrder % 2 === 0) ? "R" : "S";
                
                if (monkeyName) {
                    console.log(`Generated for ${monkeyName} try ${tryNumber}, trial ${trial}: pos(${x},${y}), z:${z}, zscaled:${zscaled}, envOrder:${envOrder}, env: ${environmentType}`);
                } else {
                    console.log(`Generated for try ${tryNumber}, trial ${trial}: pos(${x},${y}), z:${z}, zscaled:${zscaled}, envOrder:${envOrder}, env: ${environmentType}`);
                }
                
                return {
                    x,
                    y,
                    z: Math.round(z * 50), // Convert back to 0-50 range
                    zscaled,
                    baseValue,
                    noiseyValue,
                    rescaledValue,
                    scale,
                    envOrder,
                    pelletCount,
                    environmentType
                };
            } catch (e) {
                console.error("Error generating cell values:", e);
                
                // Handle fallback differently based on whether we have a monkey name
                if (monkeyName) {
                    // Return fallback values that are still unique per monkey
                    let hash = 0;
                    for (let i = 0; i < monkeyName.length; i++) {
                        hash = ((hash << 5) - hash) + monkeyName.charCodeAt(i);
                        hash |= 0; // Convert to 32bit integer
                    }
                    
                    // Use hash to create unique fallback values
                    const fallbackZ = 20 + (hash % 20);
                    return {
                        x: (trial - 1) % 8,
                        y: Math.floor((trial - 1) / 8),
                        z: fallbackZ,
                        zscaled: fallbackZ,
                        baseValue: fallbackZ,
                        noiseyValue: fallbackZ,
                        rescaledValue: fallbackZ,
                        scale: 30 + (hash % 10),
                        envOrder: (tryNumber + hash) % 4,
                        pelletCount: Math.ceil(fallbackZ / 10),
                        environmentType: (hash % 2 === 0) ? "R" : "S"
                    };
                } else {
                    // Legacy fallback
                    return {
                        x: (trial - 1) % 8,
                        y: Math.floor((trial - 1) / 8),
                        z: 25,
                        zscaled: 25,
                        baseValue: 25,
                        noiseyValue: 25,
                        rescaledValue: 25,
                        scale: 35,
                        envOrder: tryNumber % 4,
                        pelletCount: 5,
                        environmentType: "R"
                    };
                }
            }
        };
        
        // Function to safely load database from localStorage
        function loadDatabaseFromLocalStorage() {
            try {
                debugLog("Attempting to load database from localStorage", {});
                const savedDbData = localStorage.getItem('monkeyGameDb');
                
                if (!savedDbData) {
                    debugLog("No database found in localStorage", {});
                    return null;
                }
                
                // Try to parse the base64 data
                try {
                    const binaryString = atob(savedDbData);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    
                    // Convert binary string to bytes
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    
                    debugLog("Successfully parsed database binary data", { length: len });
                    return bytes;
                } catch (e) {
                    debugLog("Error parsing base64 database", e);
                    return null;
                }
            } catch (e) {
                debugLog("Error accessing localStorage", e);
                return null;
            }
        }
        
        // Function to initialize the UI with available monkeys and their try counts
        async function initExportUI() {
            try {
                // We no longer create the monkey dropdown as per requirements
                // Instead, just prepare the interface for displaying try data based on direct monkey name input
                
                // Get the monkey name from localStorage (for auto-fill)
                const lastMonkeyName = localStorage.getItem('monkeyId');
                if (lastMonkeyName) {
                    // Auto-fill the monkey name if available from the game
                    const monkeyNameInput = document.getElementById('monkeyName');
                    monkeyNameInput.value = lastMonkeyName;
                    
                    // Optionally pre-fetch data if auto-filled
                    // fetchLevel3Data();
                }
            } catch (e) {
                debugLog("Error initializing export UI", e);
            }
        }
        
        document.addEventListener('DOMContentLoaded', async function() {
            const monkeyNameInput = document.getElementById('monkeyName');
            const tryNumberSelect = document.getElementById('tryNumber');
            const tryNumberSelector = document.getElementById('tryNumberSelector');
            const fetchButton = document.getElementById('fetchButton');
            const downloadButton = document.getElementById('downloadButton');
            const downloadJsonButton = document.getElementById('downloadJsonButton');
            const errorDiv = document.getElementById('error');
            const loadingDiv = document.getElementById('loading');
            const successDiv = document.getElementById('success');
            const dataPreviewDiv = document.getElementById('dataPreview');
            const previewContentDiv = document.getElementById('previewContent');
            
            // Initialize the database connection to the in-browser DB
            try {
                debugLog("Initializing SQL.js and database connection", {});
                
                // Initialize SQL.js (with a timeout for slow connections)
                let sqlInitPromise = initSqlJs({
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
                });
                
                // Add a timeout to the promise to prevent hanging
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error("SQL.js initialization timed out")), 10000);
                });
                
                // Race the promises to handle timeout
                SQL = await Promise.race([sqlInitPromise, timeoutPromise]);
                debugLog("SQL.js initialized successfully", {});
                
                // Load database bytes using our helper function
                const dbBytes = loadDatabaseFromLocalStorage();
                
                if (dbBytes) {
                    try {
                        // Create the database from the bytes
                        db = new SQL.Database(dbBytes);
                        debugLog("Database loaded successfully from localStorage", {});
                    } catch (e) {
                        debugLog("Error creating database from bytes", e);
                        throw new Error("Failed to create database from stored data");
                    }
                } else {
                    debugLog("Creating new empty database", {});
                    db = new SQL.Database();
                    createEmptyDatabase();
                }
                
                function createEmptyDatabase() {
                    db.run(`
                        CREATE TABLE IF NOT EXISTS monkeys (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            name TEXT NOT NULL UNIQUE,
                            species TEXT
                        );
                        
                        CREATE TABLE IF NOT EXISTS levels (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            monkey_name TEXT NOT NULL,
                            level INTEGER NOT NULL,
                            try_number INTEGER NOT NULL,
                            score INTEGER,
                            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                            highest_score INTEGER DEFAULT 0
                        );
                        
                        CREATE TABLE IF NOT EXISTS trials (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            monkey_name TEXT NOT NULL,
                            level INTEGER NOT NULL,
                            trial_number INTEGER NOT NULL,
                            try_number INTEGER DEFAULT 1,
                            score INTEGER,
                            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                            tileX INTEGER,
                            tileY INTEGER,
                            clickCount INTEGER,
                            reaction_time REAL,
                            is_initial_reveal INTEGER DEFAULT 0,
                            environment TEXT,
                            scale REAL DEFAULT 1.0
                        );
                    `);
                }
            } catch (error) {
                console.error("Failed to initialize database:", error);
                debugLog("Database initialization failed", error);
                errorDiv.textContent = "Error initializing database. Using backup methods.";
                errorDiv.style.display = "block";
                
                // Try to access level3TileData directly as a fallback
                try {
                    const tileData = localStorage.getItem('level3TileData');
                    if (tileData) {
                        debugLog("Found level3TileData for fallback", { dataLength: tileData.length });
                        successDiv.textContent = "Database failed but level3TileData is available. You can still export data.";
                        successDiv.style.display = "block";
                    }
                } catch (err) {
                    debugLog("Fallback access to level3TileData also failed", err);
                }
            }
            
            // Add a direct export button
            const directExportButton = document.createElement('button');
            directExportButton.textContent = "Direct Export From Storage";
            directExportButton.style.backgroundColor = "#ff9800";
            directExportButton.style.marginTop = "10px";
            document.querySelector('.button-group').appendChild(directExportButton);
            
            directExportButton.addEventListener('click', directExportFromTileData);
            
            // Function to directly export from level3TileData bypassing database
            async function directExportFromTileData() {
                debugLog("Attempting direct export from tile data", {});
                errorDiv.style.display = 'none';
                
                try {
                    // Get tile data directly from localStorage
                    const tileDataJson = localStorage.getItem('level3TileData');
                    if (!tileDataJson) {
                        errorDiv.textContent = "No tile data found in localStorage";
                        errorDiv.style.display = 'block';
                        return;
                    }
                    
                    // Get the monkey name from the input field
                    const monkeyName = monkeyNameInput.value.trim() || "monkey";
                    
                    // Parse the data
                    const tileData = JSON.parse(tileDataJson);
                    debugLog(`Parsed tile data for direct export for monkey ${monkeyName}`, { blocks: Object.keys(tileData).length });
                    
                    // Process the tile data into our format
                    const processedData = [];
                    let rowIndex = 1;
                    
                    // Convert tile data to our export format
                    for (const block in tileData) {
                        const blockNum = parseInt(block);
                        const trialData = tileData[block];
                        
                        if (Array.isArray(trialData)) {
                            // Calculate monkey-specific scaling factors
                            const scale = calculateScale(blockNum, monkeyName);
                            const envOrder = calculateEnvOrder(blockNum, monkeyName);
                            
                            trialData.forEach(trial => {
                                // Check for stored z values for consistency - use monkey-specific storage
                                let z, zscaled;
                                const storedValues = getStoredZValue(blockNum, trial.clickNumber, monkeyName);
                                
                                if (storedValues) {
                                    // Use stored z values for consistency
                                    z = storedValues.z;
                                    zscaled = storedValues.zscaled;
                                    debugLog(`Using stored z values in direct export for ${monkeyName}`, { block: blockNum, trial: trial.clickNumber, z: z });
                                } else {
                                    // Generate values using our consistent method
                                    const cellValues = generateCellValues(blockNum, trial.clickNumber, monkeyName);
                                    z = cellValues.z;
                                    zscaled = cellValues.zscaled;
                                    
                                    // Store for future consistency in monkey-specific storage
                                    const storageKey = `level3_z_values_${monkeyName}`;
                                    const zValues = JSON.parse(localStorage.getItem(storageKey) || '{}');
                                    zValues[`${blockNum}_${trial.clickNumber}`] = { 
                                        z: z, 
                                        zscaled: zscaled,
                                        scale: cellValues.scale,
                                        envOrder: cellValues.envOrder,
                                        x: cellValues.x,
                                        y: cellValues.y,
                                        environmentType: cellValues.environmentType,
                                        monkey_name: monkeyName,
                                        pellet_count: cellValues.pelletCount || Math.ceil(z / 10) || 1
                                    };
                                    localStorage.setItem(storageKey, JSON.stringify(zValues));
                                }
                                
                                // Get pellet count from stored values for consistency or calculate
                                const storedPellet = storedValues?.pellet_count;
                                const pelletCount = trial.pelletCount || storedPellet || Math.ceil(z / 10) || Math.round(trial.rewardValue * 5) || 1;
                                
                                // Get environment type from stored values or calculate
                                const environmentType = storedValues?.environmentType || (envOrder % 2 === 0 ? "R" : "S");
                                
                                processedData.push({
                                    index: rowIndex++,
                                    x: trial.tileX,
                                    y: trial.tileY,
                                    z: z,
                                    zscaled: zscaled,
                                    trial: trial.clickNumber,
                                    block: blockNum,
                                    monkeyid: monkeyName, 
                                    scale: scale,
                                    envOrder: envOrder,
                                    pellet_count: pelletCount,
                                    environment: environmentType
                                });
                            });
                        }
                    }
                    
                    if (processedData.length === 0) {
                        errorDiv.textContent = "No valid trial data found";
                        errorDiv.style.display = 'block';
                        return;
                    }
                    
                    // Create CSV content with pellet_count and environment
                    let csvContent = '\"\",\"x\",\"y\",\"z\",\"zscaled\",\"trial\",\"block\",\"monkeyid\",\"scale\",\"envOrder\",\"pellet_count\",\"environment\"\n';
                    
                    // Add data rows with pellet count and environment type
                    processedData.forEach(row => {
                        // Determine environment type if not explicitly set
                        const environmentType = row.environment || (row.envOrder % 2 === 0 ? "R" : "S");
                        csvContent += `\"${row.index}\",${row.x},${row.y},${row.z},${row.zscaled},${row.trial},${row.block},${row.monkeyid},${row.scale},${row.envOrder},${row.pellet_count},\"${environmentType}\"\n`;
                    });
                    
                    // Generate download
                    const date = new Date().toISOString().split('T')[0];
                    const monkeyName = monkeyNameInput.value.trim() || "monkey";
                    
                    // Create and trigger download
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.setAttribute('href', url);
                    link.setAttribute('download', `${monkeyName}_Level3_DirectExport_${date}.csv`);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Show success
                    successDiv.textContent = `Direct export successful! (${processedData.length} rows)`;
                    successDiv.style.display = 'block';
                    
                } catch (error) {
                    console.error("Direct export failed:", error);
                    errorDiv.textContent = `Direct export failed: ${error.message}`;
                    errorDiv.style.display = 'block';
                }
            }
            
            monkeyNameInput.addEventListener('input', function() {
                errorDiv.style.display = 'none';
                successDiv.style.display = 'none';
                downloadButton.disabled = true;
                downloadJsonButton.disabled = true;
                dataPreviewDiv.style.display = 'none';
                tryNumberSelector.style.display = 'none';
            });
            
            tryNumberSelect.addEventListener('change', function() {
                filterAndDisplayData();
            });
            
            fetchButton.addEventListener('click', fetchLevel3Data);
            downloadButton.addEventListener('click', downloadLevel3CSV);
            downloadJsonButton.addEventListener('click', downloadLevel3JSON);
            
            // Handle enter key press
            monkeyNameInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    fetchLevel3Data();
                }
            });
            
            // Function to fetch stored try history for a monkey
            function getMonkeyTryHistory(monkeyName, level = 3) {
                try {
                    const tryHistory = JSON.parse(localStorage.getItem(`level${level}_tryHistory_${monkeyName}`) || '[]');
                    debugLog(`Found stored try history for ${monkeyName}`, tryHistory);
                    return tryHistory;
                } catch (e) {
                    debugLog(`Error getting try history for ${monkeyName}`, e);
                    return [];
                }
            }
            
            async function fetchLevel3Data() {
                const monkeyName = monkeyNameInput.value.trim();
                
                if (!monkeyName) {
                    errorDiv.textContent = 'Please enter a valid monkey name';
                    errorDiv.style.display = 'block';
                    return;
                }
                
                loadingDiv.style.display = 'block';
                successDiv.style.display = 'none';
                errorDiv.style.display = 'none';
                dataPreviewDiv.style.display = 'none';
                downloadButton.disabled = true;
                tryNumberSelector.style.display = 'none';
                
                // First, check for stored try history for this monkey
                const storedTryHistory = getMonkeyTryHistory(monkeyName);
                debugLog(`Try history for ${monkeyName}`, storedTryHistory);
                
                try {
                    // Make sure the database is initialized
                    if (!db) {
                        throw new Error("Database not initialized properly");
                    }
                    
                    debugLog("Fetching data for monkey", monkeyName);
                    
                    // First check if the monkey exists
                    try {
                        const monkeyQuery = db.prepare("SELECT name FROM monkeys WHERE name = ?");
                        monkeyQuery.bind([monkeyName]);
                        const monkeyExists = monkeyQuery.step();
                        monkeyQuery.free();
                    
                    if (!monkeyExists) {
                        // Instead of returning an error, just log it and continue
                        // This allows us to generate data even if the monkey isn't in the database
                        debugLog(`No monkey found in database: ${monkeyName}. Will attempt to use localStorage data.`, {});
                        // Don't return - continue with the function to check localStorage
                    }
                    } catch (err) {
                        debugLog("Error checking if monkey exists", err);
                        throw new Error(`Database error: ${err.message}`);
                    }
                    
                    // Clear previous data
                    trialData = [];
                    availableTryNumbers = [];
                    
                    // Get all Level 3 trials for this monkey with all fields
                    let trials = [];
                    try {
                        debugLog("Preparing to query trials", { monkey: monkeyName, level: LEVEL });
                        
                        // Use a simpler query with just * to avoid column name issues
                        const trialsQuery = db.prepare(
                            "SELECT * FROM trials WHERE monkey_name = ? AND level = ? " +
                            "ORDER BY try_number, trial_number"
                        );
                        trialsQuery.bind([monkeyName, LEVEL]);
                        
                        // Let's handle the case where there might be no data
                        let hasData = false;
                        
                        while (trialsQuery.step()) {
                            hasData = true;
                            const row = trialsQuery.getAsObject();
                            debugLog("Retrieved row", row);
                            trials.push(row);
                        }
                        trialsQuery.free();
                        
                        debugLog("Query completed", { rowCount: trials.length });
                    } catch (err) {
                        debugLog("Error querying trials data", err);
                        throw new Error(`Failed to retrieve trial data: ${err.message}`);
                    }
                    
                    if (trials.length === 0) {
                        // Check localStorage for level3TileData before showing error
                        try {
                            const tileData = localStorage.getItem('level3TileData');
                            if (tileData) {
                                debugLog("No database trials found but level3TileData exists in localStorage", {});
                                
                                // Create at least one try's worth of data from localStorage
                                const monkeyId = parseInt(monkeyName.replace(/\D/g, '')) || 4;
                                const tryNumber = 1;
                                
                                // Generate one full set of trials
                                const generatedTrials = generateDataForTryNumber(tryNumber, monkeyName);
                                if (generatedTrials && generatedTrials.length > 0) {
                                    trials = generatedTrials;
                                    debugLog("Generated fallback data from localStorage", { count: trials.length });
                                } else {
                                    throw new Error("Failed to generate trials from localStorage");
                                }
                            } else {
                                // Still no data after checking localStorage
                                errorDiv.textContent = `No Level 3 data found for monkey: ${monkeyName}`;
                                errorDiv.style.display = 'block';
                                loadingDiv.style.display = 'none';
                                return;
                            }
                        } catch (e) {
                            debugLog("Error checking localStorage for level3TileData", e);
                            errorDiv.textContent = `No Level 3 data found for monkey: ${monkeyName}`;
                            errorDiv.style.display = 'block';
                            loadingDiv.style.display = 'none';
                            return;
                        }
                    }
                    
                    // Try to load custom tile data from localStorage first
                    let customTileData = {};
                    try {
                        const savedTileData = localStorage.getItem('level3TileData');
                        if (savedTileData) {
                            customTileData = JSON.parse(savedTileData);
                            console.log("Loaded custom Level 3 tile data:", customTileData);
                        }
                    } catch (e) {
                        console.warn("Error loading custom tile data:", e);
                    }
                    
                    debugLog("Processing trial data", { count: trials.length });
                    
                    // Get unique try numbers to prevent duplicates
                    const uniqueTryNumbers = [...new Set(trials.map(t => t.try_number))];
                    debugLog("Found try numbers", uniqueTryNumbers);
                    
                    // Process the trial data
                    trialData = trials.map(trial => {
                        let tileX, tileY, clickCount, environment;
                        
                        // Check if we have custom tile data for this try_number and click
                        if (customTileData[trial.try_number]) {
                            // Find matching click data
                            const clickData = customTileData[trial.try_number].find(
                                data => data.clickNumber === trial.trial_number
                            );
                            
                            if (clickData) {
                                // Use custom tile coordinates and click count
                                tileX = clickData.tileX;
                                tileY = clickData.tileY;
                                clickCount = clickData.clickCount;
                                environment = clickData.environment;
                                console.log(`Using custom tile data for Try ${trial.try_number}, Click ${trial.trial_number}: (${tileX}, ${tileY}), Count: ${clickCount}, Env: ${environment}`);
                            }
                        }
                        
                        // Get environment from database or custom data
                        environment = trial.environment || environment || localStorage.getItem('currentEnvironmentType') || "R";
                        currentEnvironment = environment; // Update global environment tracker
                        
                        // If no custom data found, calculate based on trial number
                        if (typeof tileX === 'undefined' || typeof tileY === 'undefined') {
                            // Prefer database values if available
                            if (trial.tileX !== undefined && trial.tileY !== undefined) {
                                tileX = trial.tileX;
                                tileY = trial.tileY;
                                clickCount = trial.clickCount || 1;
                            } else {
                                // Fallback to calculated coordinates
                                const gridPosition = trial.trial_number - 1;  // zero-based
                                tileY = Math.floor(gridPosition / 8);   // Row (0-7)
                                tileX = gridPosition % 8;               // Column (0-7)
                                clickCount = 1; // Default for old data
                            }
                            
                            // For the initial revealed tile (Trial 1), set clickCount to 0
                            if (trial.trial_number === 1) {
                                clickCount = 0; // Initial reveal is not a user click
                            }
                        }
                        
                        // Get or generate monkey ID - default to a number based on the name
                        const monkeyId = parseInt(monkeyName.replace(/\D/g, '')) || 4; // Default to 4 if no numbers in name
                        
                        // Generate appropriate scale and environment values based on try_number
                        // These values are derived from patterns in the original data
                        let scale = trial.scale || (33 + (trial.try_number % 10));
                        
                        // Environment order calculated based on try number and patterns from original data
                        let envOrder = 0;
                        if (environment === "S") {
                            envOrder = 20 + (trial.try_number * 2);
                        } else {
                            envOrder = trial.try_number;
                            if (envOrder > 20) envOrder = trial.try_number % 20;
                        }
                        
                        // Chosen tile index (0-63)
                        const chosenTileIndex = tileY * 8 + tileX;
                        
                        // Get previously stored z values if available
                        let rawZ, zscaled;
                        const storedValues = getStoredZValue(trial.try_number, trial.trial_number);
                        
                        if (storedValues) {
                            // Use stored values for consistency
                            rawZ = storedValues.z;
                            zscaled = storedValues.zscaled;
                            debugLog("Using stored z values", { block: trial.try_number, trial: trial.trial_number, z: rawZ });
                        } else {
                            // Calculate consistent values based on the score
                            // This calculation must match what the game uses
                            const normalizedScore = ((trial.score || 0) / 5); // 0-1 range
                            rawZ = Math.round(normalizedScore * 50); // 0-50 range - use Math.round for consistency
                            
                            // Calculate zscaled value based on the scale
                            zscaled = Math.round(rawZ * scale / 40);
                            
                            // Calculate pellet count directly from the score to ensure consistency
                            const pelletCount = trial.score || trial.pellet_count || Math.ceil(rawZ / 10);
                            
                            // Store these values for future consistency with pellet_count included
                            const zValues = JSON.parse(localStorage.getItem('level3_z_values') || '{}');
                            zValues[`${trial.try_number}_${trial.trial_number}`] = { 
                                z: rawZ, 
                                zscaled: zscaled,
                                pellet_count: pelletCount
                            };
                            localStorage.setItem('level3_z_values', JSON.stringify(zValues));
                        }
                        
                        // Use database reaction time if available
                        const reactionTime = trial.reaction_time || 0;
                        
                        // Use database is_initial_reveal if available
                        const isInitialReveal = trial.is_initial_reveal || (trial.trial_number === 1 ? 1 : 0);
                        
                        return {
                            tileX: tileX,
                            tileY: tileY,
                            x: tileX,
                            y: tileY,
                            z: rawZ,
                            zscaled: zscaled,
                            trial: trial.trial_number,
                            block: trial.try_number,
                            monkeyid: trial.monkey_name, // Use the monkey name instead of ID number
                            scale: scale,
                            envOrder: envOrder,
                            environment: environment,
                            reactionTime: reactionTime,
                            isInitialReveal: isInitialReveal,
                            monkey_name: trial.monkey_name
                        };
                    });
                    
                    // Get unique try numbers from Level 3 data
                    const dbTryNumbers = [...new Set(trialData.map(trial => trial.block))].sort((a, b) => a - b);
                    
                    // Merge with stored try history to ensure we have all try numbers
                    let mergedTryNumbers = [...new Set([...dbTryNumbers, ...storedTryHistory])].sort((a, b) => a - b);
                    
                    if (mergedTryNumbers.length === 0) {
                        // If no try numbers found, use at least try number 1
                        mergedTryNumbers = [1];
                    }
                    
                    availableTryNumbers = mergedTryNumbers;
                    debugLog(`Available try numbers for ${monkeyName}`, availableTryNumbers);
                    
                    // Populate try number selector
                    populateTryNumberSelector(availableTryNumbers);
                    
                    // Enable download buttons
                    downloadButton.disabled = false;
                    downloadJsonButton.disabled = false;
                    
                    // Show try number selector
                    tryNumberSelector.style.display = 'block';
                    
                    // Show success message
                    successDiv.textContent = `Level 3 data found for monkey: ${monkeyName}`;
                    successDiv.style.display = 'block';
                    
                    // Show preview with filtered data
                    filterAndDisplayData();
                    
                } catch (error) {
                    console.error('Error fetching data:', error);
                    lastError = error; // Store for debugging
                    
                    // Give a more descriptive error message
                    let errorMessage = 'Error retrieving data. Please try again.';
                    if (error.message) {
                        errorMessage += ` (${error.message})`;
                    }
                    
                    errorDiv.textContent = errorMessage;
                    errorDiv.style.display = 'block';
                    
                    // If there's no data but error occurred, or if data is insufficient, generate fallback data
                    if (trialData.length === 0 || trialData.length < MIN_TRIALS_LEVEL_3) {
                        debugLog("Generating fallback data for error recovery or insufficient trials", 
                            { monkey: monkeyName, trialCount: trialData.length, required: MIN_TRIALS_LEVEL_3 });
                        generateFallbackData(monkeyName);
                    }
                } finally {
                    loadingDiv.style.display = 'none';
                }
            }
            
            // Fallback data generation function in case of database errors
            function generateFallbackData(monkeyName) {
                debugLog("Creating fallback data", { monkeyName });
                
                // Generate some sample data that matches the expected format
                trialData = [];
                const monkeyId = parseInt(monkeyName.replace(/\D/g, '')) || 4; // Default ID
                
                // Generate the requested try numbers, or at least try 1 if no tries exist
                const tryNumbers = availableTryNumbers.length > 0 ? availableTryNumbers : [1];
                
                // Generate all blocks for this monkey
                for (let block = 1; block <= Math.max(...tryNumbers, 1); block++) {
                    const scale = 35 + block;
                    const envOrder = block * 10;
                    
                    for (let trial = 1; trial <= 26; trial++) {
                        // Calculate position based on trial
                        const x = 1 + (trial % 8);
                        const y = 1 + Math.floor(trial / 8);
                        
                        // Generate z value similar to original data (range 0-50)
                        const z = Math.floor(Math.random() * 50);
                        
                        // Calculate zscaled
                        const zscaled = Math.floor(z * scale / 40);
                        
                        trialData.push({
                            monkey_name: monkeyName,
                            x: x,
                            y: y,
                            z: z,
                            zscaled: zscaled,
                            trial: trial,
                            block: block,
                            monkeyid: monkeyName, // Use the monkey name instead of ID
                            scale: scale,
                            envOrder: envOrder,
                            isInitialReveal: trial === 1 ? 1 : 0
                        });
                    }
                }
                
                // Update available try numbers - only one block in fallback
                availableTryNumbers = [1];
                
                // Enable download button and show success
                downloadButton.disabled = false;
                tryNumberSelector.style.display = 'block';
                populateTryNumberSelector(availableTryNumbers);
                filterAndDisplayData();
                
                // Show fallback message
                successDiv.textContent = `Using fallback data for demonstration (database error recovery)`;
                successDiv.style.display = 'block';
            }
            
            function populateTryNumberSelector(tryNumbers) {
                // Clear existing options except the "All" option
                while (tryNumberSelect.options.length > 1) {
                    tryNumberSelect.remove(1);
                }
                
                // Add options for each try number
                tryNumbers.forEach(tryNum => {
                    const option = document.createElement('option');
                    option.value = tryNum;
                    option.textContent = `Try #${tryNum}`;
                    tryNumberSelect.appendChild(option);
                });
                
                // Select "All" by default
                tryNumberSelect.value = 'all';
            }
            
            // Enhanced storage of z-values to ensure consistency - now monkey-specific
            function storeZValues(data, monkeyName) {
                if (!data || data.length === 0) return;
                
                // Check if we're using monkey-specific storage
                if (monkeyName) {
                    // Use the monkey name from the data if available, otherwise use the provided monkeyName
                    const actualMonkeyName = (data[0] && data[0].monkey_name) || monkeyName;
                    
                    // Use a monkey-specific storage key
                    const storageKey = `level3_z_values_${actualMonkeyName}`;
                    
                    // Get existing values first to maintain consistency
                    let zValues = {};
                    try {
                        zValues = JSON.parse(localStorage.getItem(storageKey) || '{}');
                    } catch (e) {
                        debugLog(`Error parsing existing z values for ${actualMonkeyName}, starting fresh`, e);
                        zValues = {};
                    }
                    
                    // Add new values without overwriting existing ones
                    data.forEach(trial => {
                        const key = `${trial.block}_${trial.trial}`;
                        
                        // Only store if we don't already have this value
                        if (!zValues[key] && trial.z && trial.zscaled) {
                            zValues[key] = {
                                z: trial.z,
                                zscaled: trial.zscaled,
                                pellet_count: trial.pellet_count || Math.ceil(trial.z / 10) || 1,
                                scale: trial.scale,
                                envOrder: trial.envOrder,
                                x: trial.x,
                                y: trial.y,
                                environmentType: trial.environment || (trial.envOrder % 2 === 0 ? "R" : "S"),
                                monkey_name: actualMonkeyName
                            };
                            debugLog(`Stored new z value for ${actualMonkeyName}`, { key, z: trial.z, zscaled: trial.zscaled });
                        }
                    });
                    
                    // Store in localStorage with a timestamp to track updates
                    zValues._lastUpdated = new Date().toISOString();
                    localStorage.setItem(storageKey, JSON.stringify(zValues));
                    debugLog(`Stored z-values for ${actualMonkeyName} for consistency`, { count: Object.keys(zValues).length - 1 }); // -1 for _lastUpdated
                } else {
                    // Legacy storage without monkey-specific values
                    let zValues = {};
                    try {
                        zValues = JSON.parse(localStorage.getItem('level3_z_values') || '{}');
                    } catch (e) {
                        debugLog("Error parsing existing z values, starting fresh", e);
                        zValues = {};
                    }
                    
                    // Add new values without overwriting existing ones
                    data.forEach(trial => {
                        const key = `${trial.block}_${trial.trial}`;
                        
                        // Only store if we don't already have this value
                        if (!zValues[key] && trial.z && trial.zscaled) {
                            zValues[key] = {
                                z: trial.z,
                                zscaled: trial.zscaled,
                                pellet_count: trial.pellet_count || Math.ceil(trial.z / 10) || 1
                            };
                            debugLog("Stored new z value", { key, z: trial.z, zscaled: trial.zscaled });
                        }
                    });
                    
                    // Store in localStorage with a timestamp to track updates
                    zValues._lastUpdated = new Date().toISOString();
                    localStorage.setItem('level3_z_values', JSON.stringify(zValues));
                    debugLog("Stored z-values for consistency", { count: Object.keys(zValues).length - 1 }); // -1 for _lastUpdated
                }
            }
            
            // Enhanced retrieval of stored z-values - now monkey-specific
            function getStoredZValue(block, trial, monkeyName) {
                try {
                    // Handle legacy case first (if no monkey name provided)
                    if (!monkeyName) {
                        const legacyValues = JSON.parse(localStorage.getItem('level3_z_values') || '{}');
                        const key = `${block}_${trial}`;
                        
                        if (legacyValues[key]) {
                            debugLog("Retrieved legacy stored z value", { key, z: legacyValues[key].z });
                            return legacyValues[key];
                        }
                        return null;
                    }
                    
                    // Handle monkey-specific storage
                    const storageKey = `level3_z_values_${monkeyName}`;
                    const zValues = JSON.parse(localStorage.getItem(storageKey) || '{}');
                    const key = `${block}_${trial}`;
                    
                    // If value exists, add debug info and return
                    if (zValues[key]) {
                        debugLog(`Retrieved stored z value for ${monkeyName}`, { key, z: zValues[key].z });
                        return zValues[key];
                    }
                    
                    return null;
                } catch (e) {
                    debugLog("Error retrieving z value", { block, trial, monkey: monkeyName, error: e.message });
                    return null;
                }
            }
            
            // Simplified function to generate data for a try number
            function generateDataForTryNumber(tryNumber, monkeyName) {
                debugLog(`Generating data for try ${tryNumber} using simplified methodology`, { monkey: monkeyName });
                
                const generatedData = [];
                
                // Calculate the environment type once for this try number - now monkey-specific
                const envOrder = calculateEnvOrder(tryNumber, monkeyName);
                const environmentType = (envOrder % 2 === 0) ? "R" : "S";
                
                // Calculate scale once for this try number - now monkey-specific
                const scale = calculateScale(tryNumber, monkeyName);
                
                debugLog(`Monkey ${monkeyName}, Try ${tryNumber} uses environment ${envOrder} (${environmentType}, 0-39 range) with scale ${scale}`);
                
                // Use monkey-specific storage for z-values
                const zValuesKey = `level3_z_values_${monkeyName}`;
                
                // Generate all 26 trials for this try
                for (let trial = 1; trial <= MIN_TRIALS_LEVEL_3; trial++) {
                    // First check if we already have stored values for consistency
                    const storedValues = getStoredZValue(tryNumber, trial, monkeyName);
                    
                    if (storedValues && storedValues.z && storedValues.zscaled) {
                        // Use stored values for consistency between exports
                        debugLog(`Using stored values for ${monkeyName}, try ${tryNumber}, trial ${trial}`, storedValues);
                        
                        // Make sure we have an environment type stored
                        const environment = storedValues.environmentType || environmentType;
                        
                        generatedData.push({
                            monkey_name: monkeyName,
                            block: tryNumber,
                            trial: trial,
                            x: storedValues.x || (trial - 1) % 8,
                            y: storedValues.y || Math.floor((trial - 1) / 8),
                            z: storedValues.z,
                            zscaled: storedValues.zscaled,
                            monkeyid: monkeyName,
                            scale: storedValues.scale || scale,
                            envOrder: storedValues.envOrder || envOrder,
                            pellet_count: storedValues.pellet_count || Math.ceil(storedValues.z / 10),
                            environment: environment,
                            isInitialReveal: trial === 1 ? 1 : 0
                        });
                    } else {
                        // Generate new values using our simplified methodology - now monkey-specific
                        const cellValues = generateCellValues(tryNumber, trial, monkeyName);
                        
                        // Store these values for future consistency in monkey-specific storage
                        const zValues = JSON.parse(localStorage.getItem(zValuesKey) || '{}');
                        zValues[`${tryNumber}_${trial}`] = {
                            z: cellValues.z,
                            zscaled: cellValues.zscaled,
                            pellet_count: cellValues.pelletCount,
                            scale: cellValues.scale,
                            envOrder: cellValues.envOrder,
                            x: cellValues.x,
                            y: cellValues.y,
                            environmentType: cellValues.environmentType,
                            monkey_name: monkeyName
                        };
                        localStorage.setItem(zValuesKey, JSON.stringify(zValues));
                        
                        // Add to generated data
                        generatedData.push({
                            monkey_name: monkeyName,
                            block: tryNumber,
                            trial: trial,
                            x: cellValues.x,
                            y: cellValues.y,
                            z: cellValues.z,
                            zscaled: cellValues.zscaled,
                            monkeyid: monkeyName,
                            scale: cellValues.scale,
                            envOrder: cellValues.envOrder,
                            pellet_count: cellValues.pelletCount,
                            environment: cellValues.environmentType,
                            isInitialReveal: trial === 1 ? 1 : 0
                        });
                    }
                }
                
                return generatedData;
            }
            
            function filterAndDisplayData() {
                // Get the selected try number
                const selectedTryNumber = tryNumberSelect.value;
                const monkeyName = monkeyNameInput.value.trim();
                
                // Filter data based on selection
                let filteredData;
                if (selectedTryNumber === 'all') {
                    // Get all tries - check if we need to generate data for any missing tries
                    filteredData = [];
                    
                    // Loop through all available try numbers
                    for (const tryNum of availableTryNumbers) {
                        // Get data for this try
                        let tryData = trialData.filter(trial => trial.block === tryNum);
                        
                        // If no data found for this try or insufficient trials, generate it
                        if (tryData.length === 0 || tryData.length < MIN_TRIALS_LEVEL_3) {
                            debugLog(`Insufficient trials for try ${tryNum} in "all" view: ${tryData.length}/${MIN_TRIALS_LEVEL_3}`, { monkey: monkeyName });
                            tryData = generateDataForTryNumber(tryNum, monkeyName);
                        }
                        
                        // Add to filtered data
                        filteredData.push(...tryData);
                    }
                } else {
                    // Get data for specific try
                    const tryNum = parseInt(selectedTryNumber);
                    filteredData = trialData.filter(trial => trial.block === tryNum);
                    
                    // If no data found for this try or insufficient trials, generate it
                    if (filteredData.length === 0 || filteredData.length < MIN_TRIALS_LEVEL_3) {
                        debugLog(`Insufficient trials for try ${tryNum}: ${filteredData.length}/${MIN_TRIALS_LEVEL_3}`, { monkey: monkeyName });
                        filteredData = generateDataForTryNumber(tryNum, monkeyName);
                    }
                }
                
                // Store z-values for consistency with monkey name
                if (monkeyName) {
                    storeZValues(filteredData, monkeyName);
                } else {
                    storeZValues(filteredData);  // Legacy call without monkey name
                }
                
                // Display filtered data
                displayDataPreview(filteredData);
            }
            
            function displayDataPreview(filteredData) {
                // Clear previous content
                previewContentDiv.innerHTML = '';
                
                // Add explanation of data
                const explanation = document.createElement('div');
                explanation.innerHTML = `
                    <p style="margin-bottom: 10px; font-size: 13px;">
                        Preview shows Level 3 data for spatial search experiment analysis. 
                        ${tryNumberSelect.value !== 'all' 
                         ? `Showing data for Try #${tryNumberSelect.value}.` 
                         : `Showing data for all ${availableTryNumbers.length} attempts.`}
                    </p>
                `;
                previewContentDiv.appendChild(explanation);
                
                // Add environment legend
                const legend = document.createElement('div');
                legend.innerHTML = `
                    <div style="margin-bottom: 10px; font-size: 12px; padding: 10px; background-color: #f9f9f9; border-radius: 5px;">
                        <strong>Environment Types:</strong>
                        <span style="display: inline-block; margin-left: 10px; padding: 2px 10px; background-color: rgba(200, 230, 255, 0.6); border-radius: 3px;">R = Rough</span>
                        <span style="display: inline-block; margin-left: 10px; padding: 2px 10px; background-color: rgba(255, 200, 200, 0.6); border-radius: 3px;">S = Smooth</span>
                    </div>
                `;
                previewContentDiv.appendChild(legend);
                
                // Group data by try number for summary
                const tryGroups = {};
                if (filteredData.length > 0) {
                    filteredData.forEach(trial => {
                        if (!tryGroups[trial.block]) {
                            tryGroups[trial.block] = {
                                count: 0,
                                environmentType: trial.environment || (trial.envOrder % 2 === 0 ? "R" : "S"),
                                scale: trial.scale
                            };
                        }
                        tryGroups[trial.block].count++;
                    });
                }
                
                // Add try summary if we have multiple tries
                if (Object.keys(tryGroups).length > 0) {
                    const summary = document.createElement('div');
                    summary.style.marginBottom = '15px';
                    summary.style.fontSize = '12px';
                    
                    let summaryHTML = '<strong>Environment Summary:</strong><br>';
                    Object.keys(tryGroups).sort((a, b) => parseInt(a) - parseInt(b)).forEach(tryNum => {
                        const group = tryGroups[tryNum];
                        const envColor = group.environmentType === 'R' ? 
                            'rgba(200, 230, 255, 0.6)' : 'rgba(255, 200, 200, 0.6)';
                        
                        summaryHTML += `<div style="margin: 5px 0;">Try #${tryNum}: 
                            <span style="padding: 2px 8px; background-color: ${envColor}; border-radius: 3px;">
                                ${group.environmentType} Environment
                            </span> 
                            (Scale: ${group.scale})
                        </div>`;
                    });
                    
                    summary.innerHTML = summaryHTML;
                    previewContentDiv.appendChild(summary);
                }
                
                // Create a table for the new format data
                const table = document.createElement('table');
                table.className = 'preview-table';
                
                // Create headers with all requested variables
                const header = document.createElement('thead');
                header.innerHTML = `
                    <tr>
                        <th>#</th>
                        <th>x</th>
                        <th>y</th>
                        <th>z</th>
                        <th>zscaled</th>
                        <th>trial</th>
                        <th>block</th>
                        <th>monkeyid</th>
                        <th>scale</th>
                        <th>envOrder</th>
                        <th>pellet_count</th>
                        <th>env</th>
                    </tr>
                `;
                table.appendChild(header);
                
                // Create body
                const body = document.createElement('tbody');
                
                if (filteredData.length > 0) {
                    // Sort trials by block, then trial for proper sequencing
                    const sortedTrials = [...filteredData].sort((a, b) => {
                        if (a.block !== b.block) return a.block - b.block;
                        return a.trial - b.trial;
                    });
                    
                    // Filter to respect maximum trials
                    const validTrials = sortedTrials.filter(trial => 
                        trial.trial <= MAX_TRIALS_LEVEL_3
                    );
                    
                    // Limit preview to 20 rows maximum to avoid overwhelming the UI
                    const previewTrials = validTrials.slice(0, 20);
                    
                    // Create rows
                    previewTrials.forEach((trial, index) => {
                        const row = document.createElement('tr');
                        
                        // Determine environment type (R/S) and set background color accordingly
                        const environmentType = trial.environment || (trial.envOrder % 2 === 0 ? "R" : "S");
                        
                        // Set background color based on environment type
                        row.style.backgroundColor = environmentType === 'R' ? 
                            'rgba(200, 230, 255, 0.3)' : 'rgba(255, 200, 200, 0.3)';
                        
                        // Calculate pellet count if needed
                        const pelletCount = trial.pellet_count || trial.rawScore || Math.round(trial.z / 10);
                        
                        row.innerHTML = `
                            <td>${index + 1}</td>
                            <td>${trial.x}</td>
                            <td>${trial.y}</td>
                            <td>${trial.z}</td>
                            <td>${trial.zscaled}</td>
                            <td>${trial.trial}</td>
                            <td>${trial.block}</td>
                            <td>${trial.monkeyid}</td>
                            <td>${trial.scale}</td>
                            <td>${trial.envOrder}</td>
                            <td>${pelletCount}</td>
                            <td style="font-weight: bold;">${environmentType}</td>
                        `;
                        body.appendChild(row);
                    });
                    
                    // If we limited the preview, show a message
                    if (validTrials.length > 20) {
                        const infoRow = document.createElement('tr');
                        infoRow.innerHTML = `
                            <td colspan="12" style="text-align: center; font-style: italic; padding: 10px;">
                                Showing 20 of ${validTrials.length} rows. Download CSV for complete data.
                            </td>
                        `;
                        body.appendChild(infoRow);
                    }
                } else {
                    const noDataRow = document.createElement('tr');
                    noDataRow.innerHTML = `
                        <td colspan="12" style="text-align: center; padding: 10px;">
                            No data available for the selected criteria.
                        </td>
                    `;
                    body.appendChild(noDataRow);
                }
                
                table.appendChild(body);
                
                // Add the table to the preview
                previewContentDiv.appendChild(table);
                
                // Show the preview
                dataPreviewDiv.style.display = 'block';
            }
            
            // Helper function to get filtered data for downloads
            function getFilteredDataForDownload() {
                // Get the selected try number
                const selectedTryNumber = tryNumberSelect.value;
                const monkeyName = monkeyNameInput.value.trim();
                
                // Filter data based on selection, handling missing tries
                let filteredData;
                if (selectedTryNumber === 'all') {
                    // Get all tries - check if we need to generate data for any missing tries
                    filteredData = [];
                    
                    // Loop through all available try numbers
                    for (const tryNum of availableTryNumbers) {
                        // Get data for this try
                        let tryData = trialData.filter(trial => trial.block === tryNum);
                        
                        // If no data found for this try or insufficient trials, generate it
                        if (tryData.length === 0 || tryData.length < MIN_TRIALS_LEVEL_3) {
                            debugLog(`Insufficient trials for try ${tryNum} in download: ${tryData.length}/${MIN_TRIALS_LEVEL_3}`, { monkey: monkeyName });
                            tryData = generateDataForTryNumber(tryNum, monkeyName);
                        }
                        
                        // Add to filtered data
                        filteredData.push(...tryData);
                    }
                } else {
                    // Get data for specific try
                    const tryNum = parseInt(selectedTryNumber);
                    filteredData = trialData.filter(trial => trial.block === tryNum);
                    
                    // If no data found for this try or insufficient trials, generate it
                    if (filteredData.length === 0 || filteredData.length < MIN_TRIALS_LEVEL_3) {
                        debugLog(`Insufficient trials for try ${tryNum}: ${filteredData.length}/${MIN_TRIALS_LEVEL_3}`, { monkey: monkeyName });
                        filteredData = generateDataForTryNumber(tryNum, monkeyName);
                    }
                }
                
                if (filteredData.length === 0) {
                    return null;
                }
                
                debugLog("Data filtered for download", { count: filteredData.length });
                
                // Filter to respect maximum trials
                const validTrials = filteredData.filter(trial => 
                    trial.trial <= MAX_TRIALS_LEVEL_3
                );
                
                // Sort trials by block, then trial
                const sortedTrials = [...validTrials].sort((a, b) => {
                    if (a.block !== b.block) return a.block - b.block;
                    return a.trial - b.trial;
                });
                
                return {
                    sortedTrials: sortedTrials,
                    monkeyName: monkeyName,
                    selectedTryNumber: selectedTryNumber
                };
            }
            
            // Function to download CSV file
            function downloadLevel3CSV() {
                debugLog("Starting CSV download process with original experiment format", {});
                
                try {
                    const downloadData = getFilteredDataForDownload();
                    
                    if (!downloadData) {
                        errorDiv.textContent = 'No data available to download';
                        errorDiv.style.display = 'block';
                        return;
                    }
                    
                    const { sortedTrials, monkeyName, selectedTryNumber } = downloadData;
                    
                    // Create CSV header in the format expected by spatial search analysis
                    // This format matches the original experiment output format with added environment
                    let csvContent = 'monkeyname,block,trial,x,y,z,zscaled,scale,envOrder,LocationX,LocationY,Value,IsInitialReveal,GridPosition,ReactionTime,environment\n';
                    
                    // Add data rows in the format matching the original experiment
                    sortedTrials.forEach(row => {
                        // Calculate grid position (0-63)
                        const gridPos = row.y * 8 + row.x;
                        
                        // Use stored reaction time or generate a realistic one
                        const reactionTime = row.reactionTime || (Math.random() * 900 + 300).toFixed(2);
                        
                        // For the original experiment format, we need:
                        // monkeyname = monkey name
                        // block = try number
                        // trial = trial number
                        // x, y = grid coordinates (0-7)
                        // z = reward value (0.0-1.0 range)
                        // zscaled = normalized reward value
                        // scale = scale factor (30-40 range)
                        // envOrder = environment index
                        // LocationX/Y = same as x,y
                        // Value = reward value
                        // IsInitialReveal = 1 for first trial, 0 for others
                        // GridPosition = index of tile in grid (0-63)
                        // ReactionTime = time to make decision
                        
                        // Calculate z value formatted like original (0.0-1.0 range)
                        const z = (row.z / 50).toFixed(2);
                        
                        // Determine environment type
                        const environmentType = row.environment || (row.envOrder % 2 === 0 ? "R" : "S");
                        
                        csvContent += `${row.monkeyid},${row.block},${row.trial},${row.x},${row.y},${z},${row.zscaled},${row.scale},${row.envOrder},${row.x},${row.y},${z},${row.isInitialReveal || (row.trial === 1 ? 1 : 0)},${gridPos},${reactionTime},${environmentType}\n`;
                    });
                    
                    // Download the CSV with descriptive filename
                    const date = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
                    const tryNumberText = selectedTryNumber === 'all' ? 'AllTries' : `Try${selectedTryNumber}`;
                    
                    // Create and trigger download
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.setAttribute('href', url);
                    link.setAttribute('download', `${monkeyName}_Level3_${tryNumberText}_${date}.csv`);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Show success message
                    successDiv.textContent = `Level 3 data exported in original format successfully!`;
                    successDiv.style.display = 'block';
                    
                    debugLog("CSV download completed successfully in original format", {});
                } catch (error) {
                    console.error("Error during CSV download:", error);
                    errorDiv.textContent = `Error during download: ${error.message}`;
                    errorDiv.style.display = 'block';
                }
            }
            
            // Function to download JSON file
            function downloadLevel3JSON() {
                debugLog("Starting JSON download process in original format", {});
                
                try {
                    const downloadData = getFilteredDataForDownload();
                    
                    if (!downloadData) {
                        errorDiv.textContent = 'No data available to download';
                        errorDiv.style.display = 'block';
                        return;
                    }
                    
                    const { sortedTrials, monkeyName, selectedTryNumber } = downloadData;
                    
                    // Prepare JSON data in original experiment format
                    const jsonData = sortedTrials.map(row => {
                        // Calculate grid position (0-63)
                        const gridPos = row.y * 8 + row.x;
                        
                        // Use stored reaction time or generate a realistic one
                        const reactionTime = row.reactionTime || parseFloat((Math.random() * 900 + 300).toFixed(2));
                        
                        // Calculate z value formatted like original (0.0-1.0 range)
                        const z = parseFloat((row.z / 50).toFixed(2));
                        
                        return {
                            monkeyname: row.monkeyid,
                            block: row.block,
                            trial: row.trial,
                            x: row.x,
                            y: row.y,
                            z: z,
                            zscaled: row.zscaled,
                            scale: row.scale,
                            envOrder: row.envOrder,
                            LocationX: row.x,
                            LocationY: row.y,
                            Value: z,
                            IsInitialReveal: row.isInitialReveal || (row.trial === 1 ? 1 : 0),
                            GridPosition: gridPos,
                            ReactionTime: reactionTime,
                            environment: row.environment || (row.envOrder % 2 === 0 ? "R" : "S")
                        };
                    });
                    
                    // Organize data by try numbers/blocks
                    const organizedData = {};
                    
                    // Group trials by block (try number)
                    sortedTrials.forEach(row => {
                        const blockKey = row.block.toString();
                        if (!organizedData[blockKey]) {
                            organizedData[blockKey] = [];
                        }
                        
                        // Calculate grid position and normalized z value
                        const gridPos = row.y * 8 + row.x;
                        const z = parseFloat((row.z / 50).toFixed(2));
                        
                        // Add trial data in format similar to original
                        organizedData[blockKey].push({
                            tileX: row.x,
                            tileY: row.y,
                            clickNumber: row.trial,
                            rewardValue: z,
                            scale: row.scale,
                            envOrder: row.envOrder,
                            environment: row.environment || (row.envOrder % 2 === 0 ? "R" : "S"),
                            clickCount: row.trial === 1 ? 0 : 1, // Initial reveal is 0, others are 1
                            zscaled: row.zscaled,
                            gridPosition: gridPos,
                            isInitialReveal: row.trial === 1 ? 1 : 0
                        });
                    });
                    
                    // Create full export object like the original experiment
                    const exportObject = {
                        participantId: monkeyName,
                        session: `Level3_Export_${new Date().toISOString()}`,
                        scale: Object.keys(organizedData).map(block => calculateScale(parseInt(block))),
                        envOrder: Object.keys(organizedData).map(block => calculateEnvOrder(parseInt(block), block % 2 === 0 ? "R" : "S")),
                        searchHistory: {
                            trialData: jsonData,
                            organizedByBlock: organizedData
                        }
                    };
                    
                    // Create JSON content
                    const jsonContent = JSON.stringify(exportObject, null, 2);
                    
                    // Download the JSON with descriptive filename
                    const date = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
                    const tryNumberText = selectedTryNumber === 'all' ? 'AllTries' : `Try${selectedTryNumber}`;
                    
                    // Create and trigger download
                    const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.setAttribute('href', url);
                    link.setAttribute('download', `${monkeyName}_Level3_${tryNumberText}_${date}.json`);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Show success message
                    successDiv.textContent = `Level 3 data exported as JSON successfully in original format!`;
                    successDiv.style.display = 'block';
                    
                    debugLog("JSON download completed successfully in original format", {});
                } catch (error) {
                    console.error("Error during JSON download:", error);
                    errorDiv.textContent = `Error during download: ${error.message}`;
                    errorDiv.style.display = 'block';
                }
            }
            
            // Automatically focus the input field when the page loads
            monkeyNameInput.focus();
            
            // Initialize the UI with available monkeys and tries
            initExportUI();
        });
    </script>
</body>
</html>