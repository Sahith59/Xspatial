<!DOCTYPE html>
<html>
<head>
    <title>Xspatial Browser Game</title>
    <meta charset="UTF-8">
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .welcome-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 400px;
            text-align: center;
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
        }

        input {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            box-sizing: border-box;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input:focus {
            border-color: #4CAF50;
            outline: none;
        }

        button {
            background: #4CAF50;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 20px;
        }

        button:hover {
            background: #45a049;
        }

        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .error {
            color: #ff0000;
            font-size: 14px;
            margin-top: 5px;
            display: none;
        }

        .loading {
            display: none;
            margin-top: 10px;
            color: #666;
        }

        #welcome-screen {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        #game-screen {
            display: none;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .admin-indicator {
            position: fixed;
            bottom: 5px;
            right: 5px;
            font-size: 10px;
            color: rgba(255,255,255,0.3);
            padding: 3px;
            z-index: 1000;
        }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #loading-message {
            color: white;
            margin-top: 20px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div>
            <div class="spinner"></div>
            <div id="loading-message">Loading game...</div>
        </div>
    </div>

    <div id="game-container">
        <div id="welcome-screen">
            <div class="welcome-container">
                <h1>Welcome to the Game</h1>
                <div class="input-group">
                    <input type="text" id="monkeyId" placeholder="Enter Monkey Name" autocomplete="off">
                    <div id="error" class="error">Please enter a valid name</div>
                </div>
                <div id="loading" class="loading">Connecting to server...</div>
                <button id="startButton" onclick="startGame()">Start Game</button>
            </div>
        </div>

        <div id="game-screen">
            <canvas id="gameCanvas"></canvas>
            <!-- Add audio element for the correct sound -->
            <audio id="correctSound" src="correct.wav" preload="auto" muted="false"></audio>
            <div class="admin-indicator">
                Admin Panel: Ctrl+Shift+A |
                <a href="#" onclick="showPelletConfig(); return false;" style="color: rgba(255,255,255,0.5); text-decoration: none;">Pellet Config</a>
            </div>
        </div>
    </div>


    <!-- Game Logic -->
    <script>
        // Simple game data storage (no database needed)
        let gameData = {
            currentPlayer: null,
            currentLevel: 1,
            gameStats: [],
            initialized: false
        };

        // Simple functions for storing game data in localStorage
        function storeTrialData(score, tileX, tileY, clickCount) {
            const monkeyId = localStorage.getItem('monkeyId');
            const gameStats = JSON.parse(localStorage.getItem('gameStats') || '[]');
            
            gameStats.push({
                player: monkeyId,
                level: currentLevel,
                trial: clicks,
                score: score,
                tileX: tileX,
                tileY: tileY,
                clickCount: clickCount,
                timestamp: new Date().toISOString()
            });
            
            localStorage.setItem('gameStats', JSON.stringify(gameStats));
            console.log(`Trial ${clicks} data stored: score=${score}`);
        }

        function storeLevelData(totalScore) {
            const monkeyId = localStorage.getItem('monkeyId');
            const levelData = JSON.parse(localStorage.getItem('levelData') || '{}');
            
            if (!levelData[monkeyId]) {
                levelData[monkeyId] = {};
            }
            
            levelData[monkeyId][`level${currentLevel}`] = {
                score: totalScore,
                completed: new Date().toISOString()
            };
            
            localStorage.setItem('levelData', JSON.stringify(levelData));
            console.log(`Level ${currentLevel} completed with score: ${totalScore}`);
        }


        // Welcome screen functionality
        document.addEventListener('DOMContentLoaded', async function() {
            // Hide loading overlay - no external data needed
            document.getElementById('loading-overlay').style.display = 'none';

            const input = document.getElementById('monkeyId');
            const startButton = document.getElementById('startButton');
            const errorDiv = document.getElementById('error');
            const loadingDiv = document.getElementById('loading');

            input.addEventListener('input', function() {
                const value = this.value.trim();
                startButton.disabled = value.length === 0;
                errorDiv.style.display = 'none';
            });

            // Handle enter key
            input.addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !startButton.disabled) {
                    startGame();
                }
            });
        });

        async function startGame() {
            const input = document.getElementById('monkeyId');
            const startButton = document.getElementById('startButton');
            const errorDiv = document.getElementById('error');
            const loadingDiv = document.getElementById('loading');

            const monkeyId = input.value.trim();

            if (monkeyId.length === 0) {
                errorDiv.textContent = 'Please enter a valid name';
                errorDiv.style.display = 'block';
                return;
            }

            startButton.disabled = true;
            loadingDiv.style.display = 'block';
            errorDiv.style.display = 'none';

            try {
                // Store the monkey name
                localStorage.setItem('monkeyId', monkeyId);

                // Check browser and suggest Chrome for best experience
                const isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
                if (!isChrome) {
                    console.log('ðŸ’¡ For best performance and persistence, consider using Chrome browser');
                }

                // *** CRITICAL CHECK: If player has already reached Level 3, redirect immediately ***
                const playerLevel3Key = `playerLevel3Status_${monkeyId}`;
                const isLevel3Player = localStorage.getItem(playerLevel3Key) === 'true';
                
                if (isLevel3Player) {
                    console.log(`ðŸŽ¯ LEVEL 3 PLAYER DETECTED (${monkeyId}) - Redirecting to testbrowser.html`);
                    
                    // Instant redirect with no messages
                    window.location.href = 'testbrowser.html';
                    return;
                }

                // Check for existing saved game state
                const hasSavedState = loadGameState();
                
                if (hasSavedState) {
                    console.log(`ðŸ”„ Resuming saved game for player: ${monkeyId}`);
                    console.log(`ðŸŽ¯ Continuing Level ${currentLevel}, Trial ${clicks + 1}`);
                } else {
                    // Initialize game state for new player or fresh start
                    currentLevel = 1;
                    clicks = 0;
                    gameResults = [];
                    squares = [];
                    revealedSquares = new Set();
                    const tryNumberKey = getUserTryNumberKey(monkeyId);
                    localStorage.setItem(tryNumberKey, '1');
                    console.log(`ðŸŽ¯ Starting fresh - Level ${currentLevel}, Try 1 for player: ${monkeyId}`);
                }

                // Switch to game screen
                document.getElementById('welcome-screen').style.display = 'none';
                document.getElementById('game-screen').style.display = 'block';

                // Initialize game
                init();
                
                console.log(`ðŸŽ® Game started/resumed for player: ${monkeyId}`);
                
            } catch (error) {
                console.error('ðŸ’¥ CRITICAL ERROR starting game:', error);
                errorDiv.textContent = 'Failed to start game. Check console for details.';
                errorDiv.style.display = 'block';
                startButton.disabled = false;
                loadingDiv.style.display = 'none';
                
                // Switch back to welcome screen
                document.getElementById('welcome-screen').style.display = 'flex';
                document.getElementById('game-screen').style.display = 'none';
            }
        }

        // Game code starts here
        // Pellet dispenser configuration
        let pelletDispenser = {
            isConfigured: false,
            serverUrl: 'http://127.0.0.1:5050/dispense_pellet',
            enabled: true,
            exePath: 'C:\\Program Files\\Pellet\\pellet.exe', // Path to the pellet.exe on Windows
            configure: function() {
                // Try to load pellet configuration
                const savedConfig = localStorage.getItem('pelletConfig');
                if (savedConfig) {
                    try {
                        const config = JSON.parse(savedConfig);
                        this.enabled = config.enabled || false;
                        this.serverUrl = config.serverUrl || 'http://127.0.0.1:5050/dispense_pellet';
                        this.exePath = config.exePath || '';
                        this.isConfigured = true;

                        console.log("Loaded pellet dispenser configuration:", config);
                    } catch (e) {
                        console.warn("Error loading pellet configuration, using defaults", e);
                    }
                }
            },
            save: function() {
                localStorage.setItem('pelletConfig', JSON.stringify({
                    enabled: this.enabled,
                    serverUrl: this.serverUrl,
                    exePath: this.exePath
                }));
                console.log("Saved pellet configuration");
            }
        };

        // Configure pellet dispenser
        pelletDispenser.configure();

        // Function to show pellet configuration UI
        function showPelletConfig() {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            overlay.style.zIndex = '9999';
            overlay.style.display = 'flex';
            overlay.style.justifyContent = 'center';
            overlay.style.alignItems = 'center';

            // Create modal dialog
            const modal = document.createElement('div');
            modal.style.backgroundColor = 'white';
            modal.style.padding = '20px';
            modal.style.borderRadius = '10px';
            modal.style.width = '80%';
            modal.style.maxWidth = '500px';
            modal.style.maxHeight = '80%';
            modal.style.overflowY = 'auto';

            // Create form content
            modal.innerHTML = `
                <h2 style="margin-top: 0; color: #333;">Pellet Dispenser Configuration</h2>
                <p>Configure settings for the pellet dispenser. This is only needed on Windows with a physical dispenser.</p>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;">
                        <input type="checkbox" id="pellet-enabled" ${pelletDispenser.enabled ? 'checked' : ''}>
                        Enable Pellet Dispenser
                    </label>
                    <small style="color: #666;">Turn on/off pellet dispenser functionality</small>
                </div>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;">Server URL:</label>
                    <input type="text" id="pellet-url" value="${pelletDispenser.serverUrl}" style="width: 100%; padding: 8px; box-sizing: border-box;">
                    <small style="color: #666;">URL of pellet server (default: http://127.0.0.1:5050/dispense_pellet)</small>
                </div>

                <div style="margin-bottom: 15px; border: 2px solid #ffcc00; padding: 10px; border-radius: 5px; background-color: #fffef0;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold; color: #333;">Pellet.exe Path (Windows only):</label>
                    <input type="text" id="pellet-path" value="${pelletDispenser.exePath}" style="width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ffcc00;">
                    <small style="color: #333;"><strong>IMPORTANT:</strong> Enter the full path to pellet.exe on Windows</small>
                    <div style="margin-top: 8px; font-size: 13px;">
                        <strong>Example paths:</strong>
                        <ul style="margin-top: 5px; padding-left: 20px;">
                            <li>C:\\Program Files\\Pellet\\pellet.exe</li>
                            <li>C:\\Xspatial\\resources\\bin\\pellet.exe</li>
                            <li>D:\\Game\\pellet.exe</li>
                        </ul>
                    </div>
                </div>

                <div style="margin-bottom: 15px; color: #333; font-size: 14px; padding: 10px; background: #f5f5f5; border-radius: 5px;">
                    <p style="margin-top: 0;"><strong>How to use with physical pellet dispenser:</strong></p>
                    <ol style="margin-top: 5px; padding-left: 20px;">
                        <li>Run <code>start_pellet_server.bat</code> on your Windows machine</li>
                        <li>Enable the dispenser using the checkbox above</li>
                        <li>Enter the <strong>exact path</strong> to pellet.exe</li>
                        <li>Click Save</li>
                        <li>The physical dispenser will be used when rewarding points</li>
                    </ol>
                    <p style="margin-bottom: 0;"><em>On non-Windows systems, pellet dispensing will be simulated</em></p>
                </div>

                <div style="text-align: right; margin-top: 20px;">
                    <button id="pellet-cancel" style="padding: 8px 15px; margin-right: 10px; background: #ccc; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                    <button id="pellet-save" style="padding: 8px 15px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Save</button>
                </div>
            `;

            // Add modal to page
            overlay.appendChild(modal);
            document.body.appendChild(overlay);

            // Add event listeners
            document.getElementById('pellet-cancel').addEventListener('click', () => {
                document.body.removeChild(overlay);
            });

            document.getElementById('pellet-save').addEventListener('click', () => {
                // Save configuration
                pelletDispenser.enabled = document.getElementById('pellet-enabled').checked;
                pelletDispenser.serverUrl = document.getElementById('pellet-url').value.trim();
                pelletDispenser.exePath = document.getElementById('pellet-path').value.trim();
                pelletDispenser.isConfigured = true;
                pelletDispenser.save();

                // Close modal
                document.body.removeChild(overlay);

                // Show confirmation
                alert("Pellet dispenser configuration saved. " +
                      (pelletDispenser.enabled ? "Dispenser is ENABLED." : "Dispenser is DISABLED."));
            });
        }

        // Function to play the correct sound multiple times based on score
        function playCorrectSound(count = 1) {
            console.log(`ATTEMPTING TO PLAY SOUND ${count} times`);

            // Create a new Audio object directly instead of using the DOM element
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    const audio = new Audio('correct.wav');
                    audio.volume = 1.0;

                    console.log(`Playing sound ${i + 1} of ${count}`);

                    audio.play().then(() => {
                        console.log(`Successfully played sound ${i + 1}`);
                    }).catch(error => {
                        console.error(`Failed to play sound ${i + 1}:`, error);

                        // Fallback: try with the DOM element
                        const domSound = document.getElementById('correctSound');
                        if (domSound) {
                            domSound.currentTime = 0;
                            domSound.play().catch(err => {
                                console.error('Fallback sound also failed:', err);
                            });
                        }
                    });
                }, i * 600); // 600ms delay between sounds
            }
        }

        // Test audio function - call this manually to test
        function testAudio() {
            console.log('Testing audio...');
            const audio = new Audio('correct.wav');
            audio.volume = 1.0;
            audio.play().then(() => {
                console.log('Audio test successful!');
            }).catch(error => {
                console.error('Audio test failed:', error);
            });
        }

        // Make testAudio available globally for debugging
        window.testAudio = testAudio;

        // Initialize audio for browser compatibility
        let audioInitialized = false;
        function initializeAudio() {
            console.log('Initializing audio...');

            // Test if audio file exists
            const testAudio = new Audio('correct.wav');
            testAudio.addEventListener('loadstart', () => console.log('Audio loading started'));
            testAudio.addEventListener('canplay', () => console.log('Audio can play'));
            testAudio.addEventListener('error', (e) => console.error('Audio load error:', e));

            // Enable audio context on first user interaction
            document.addEventListener('click', function enableAudio() {
                console.log('First click detected, enabling audio...');
                testAudio.play().then(() => {
                    testAudio.pause();
                    testAudio.currentTime = 0;
                    audioInitialized = true;
                    console.log('Audio context enabled successfully');
                }).catch(err => {
                    console.warn('Audio context enable failed:', err);
                });
                // Remove the listener after first use
                document.removeEventListener('click', enableAudio);
            }, { once: true });
        }

        // Add reaction time tracking
        let clickStartTime = 0;
        let clickDurations = {};

        // Function to start tracking click response time
        function startClickTimer() {
            clickStartTime = performance.now();
        }

        // Function to record click duration
        function recordClickDuration(tileId, trialNumber) {
            const endTime = performance.now();
            const duration = endTime - clickStartTime;

            // Store in clickDurations object
            if (!clickDurations[trialNumber]) {
                clickDurations[trialNumber] = {};
            }
            clickDurations[trialNumber] = {
                tileId: tileId,
                duration: duration
            };

            // Reset timer
            clickStartTime = 0;
            return duration;
        }

        // Dispense pellets function
        async function dispensePellets(count) {
            try {
                // If pellet dispenser is disabled, just log and return
                if (!pelletDispenser.enabled) {
                    console.log(`[SIMULATED] Dispensing ${count} pellet(s) - dispenser disabled`);
                    return;
                }

                console.log(`Dispensing ${count} pellet(s)`);

                // Attempt to use pellet server
                try {
                    const response = await fetch(pelletDispenser.serverUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            count: count,
                            exePath: pelletDispenser.exePath // Pass the exe path to the server
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to connect to pellet server');
                    }

                    const data = await response.json();
                    console.log('Pellet dispensed via server:', data);
                } catch (fetchError) {
                    console.warn('Non-critical: Failed to dispense pellet via server:', fetchError);
                    console.log('[SIMULATED] Dispensing pellets in web mode');
                }
            } catch (error) {
                // Don't fail the game if pellet dispensing fails
                console.warn('Non-critical error dispensing pellet:', error);
            }
        }

        // Simple training game - no external data files needed


        // Simple reward function for training game
        function getTrainingReward(tileX, tileY) {
            // Simple random reward for training
            return Math.random() * 5;
        }


        // Initialize canvas and context
        let canvas, ctx;

        // Game state variables
        let squares = [];
        let clicks = 0;
        let sunPosition = 0;
        let isWaiting = false;
        let gameActive = true;
        let timeoutId = null;
        let gameResults = [];
        let currentLevel = 1;
        let squareColors = [];
        let revealedSquares = new Set();
        let level1BestScore = 0;
        let gridSquares = [];
        let hasPassedLevel2 = false;
        let SQUARE_SIZE;
        let SUN_MARGIN;

        let lastScreenWidth;
        let lastScreenHeight;

        // Constants
        const MAX_CLICKS = 10;
        const ITI_DURATION = 500;
        const BLANK_SCREEN_DURATION = 30000; // 30 seconds between levels
        const ANIMATION_DURATION = 200;
        const REVEAL_ANIMATION_DURATION = 500;
        const MIN_SCORE_FOR_LEVEL2 = 40;
        const MIN_SCORE_FOR_LEVEL3 = 80; // Need 80% of max possible score in Level 2
        const GRID_SIZE = 8;

        // Add this new constant for Level 2 trials
        const LEVEL2_TRIALS = 20;

        // 2. Ensure the getTrialCount function returns the correct number for each level
        function getTrialCount(level) {
            if (level === 1) {
                return MAX_CLICKS;       // Level 1: 10 trials
            } else if (level === 2) {
                return LEVEL2_TRIALS;    // Level 2: 20 trials
            }
            return MAX_CLICKS; // Fallback
        }

        const ENVIRONMENT_TYPES = {
            ROUGH: 'R',
            SMOOTH: 'S'
        };

        const COLORS = [
            '#FFE5B4',
            '#FFD699',
            '#FFB080',
            '#E67550',
            '#CC4433'
        ];

        // ========== USER-SPECIFIC PERSISTENT GAME STATE FUNCTIONS ==========
        
        function getUserGameStateKey(playerId) {
            return `browserGameState_${playerId}`;
        }

        function getUserTrialResultsKey(playerId) {
            return `allTrialResults_${playerId}`;
        }

        function getUserTryNumberKey(playerId) {
            return `currentTryNumber_${playerId}`;
        }

        function saveGameState() {
            const playerId = localStorage.getItem('monkeyId');
            if (!playerId) {
                console.warn('âš ï¸ No playerId found - cannot save game state');
                return;
            }

            const gameState = {
                currentLevel: currentLevel,
                clicks: clicks,
                squares: squares.map(square => ({
                    x: square.x,
                    y: square.y,
                    value: square.value,
                    color: square.color,
                    isRevealed: square.isRevealed,
                    isClickable: square.isClickable
                })),
                revealedSquares: Array.from(revealedSquares),
                gameActive: gameActive,
                gameResults: gameResults,
                sunPosition: sunPosition,
                timestamp: Date.now(),
                playerId: playerId
            };
            
            const key = getUserGameStateKey(playerId);
            localStorage.setItem(key, JSON.stringify(gameState));
            console.log(`ðŸ”„ Game state saved for ${playerId}:`, gameState);
        }

        function loadGameState() {
            try {
                const playerId = localStorage.getItem('monkeyId');
                if (!playerId) {
                    console.log('ðŸ“ No playerId found - starting fresh');
                    return false;
                }

                const key = getUserGameStateKey(playerId);
                const savedState = localStorage.getItem(key);
                if (!savedState) {
                    console.log(`ðŸ“ No saved game state found for ${playerId} - starting fresh`);
                    return false;
                }

                const gameState = JSON.parse(savedState);
                
                // Check if state belongs to current player
                if (gameState.playerId !== playerId) {
                    console.log(`âš ï¸ Game state belongs to different player (${gameState.playerId}) - starting fresh for ${playerId}`);
                    return false;
                }
                
                // Check if state is recent (within 24 hours)
                const hoursSinceLastSave = (Date.now() - gameState.timestamp) / (1000 * 60 * 60);
                if (hoursSinceLastSave > 24) {
                    console.log(`â° Saved state too old for ${playerId} - starting fresh`);
                    localStorage.removeItem(key);
                    return false;
                }

                // Restore game state
                currentLevel = gameState.currentLevel || 1;
                clicks = gameState.clicks || 0;
                gameActive = gameState.gameActive !== undefined ? gameState.gameActive : true;
                gameResults = gameState.gameResults || [];
                sunPosition = gameState.sunPosition || 0;
                revealedSquares = new Set(gameState.revealedSquares || []);
                
                // Restore squares if they exist
                if (gameState.squares && gameState.squares.length > 0) {
                    squares = gameState.squares.map(square => ({
                        x: square.x,
                        y: square.y,
                        value: square.value,
                        color: square.color,
                        isRevealed: square.isRevealed !== undefined ? square.isRevealed : false,
                        isClickable: square.isClickable !== undefined ? square.isClickable : true
                    }));
                }

                console.log(`âœ… Game state restored for ${playerId}:`, gameState);
                console.log(`ðŸŽ¯ Continuing Level ${currentLevel}, Trial ${clicks + 1}`);
                return true;
            } catch (error) {
                console.error('âŒ Error loading game state:', error);
                const playerId = localStorage.getItem('monkeyId');
                if (playerId) {
                    localStorage.removeItem(getUserGameStateKey(playerId));
                }
                return false;
            }
        }

        function clearGameState() {
            const playerId = localStorage.getItem('monkeyId');
            if (playerId) {
                localStorage.removeItem(getUserGameStateKey(playerId));
                console.log(`ðŸ—‘ï¸ Game state cleared for ${playerId}`);
            }
        }

        function saveTrialResult(score, trialNumber) {
            const playerId = localStorage.getItem('monkeyId');
            if (!playerId) return;

            // Save individual trial result
            const trialData = {
                level: currentLevel,
                trial: trialNumber,
                score: score,
                timestamp: Date.now(),
                playerId: playerId
            };
            
            const key = getUserTrialResultsKey(playerId);
            let allTrials = JSON.parse(localStorage.getItem(key) || '[]');
            allTrials.push(trialData);
            localStorage.setItem(key, JSON.stringify(allTrials));
            
            // Also save current game progress
            saveGameState();
        }

        // Function to toggle fullscreen
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // Handle keyboard events for fullscreen
        function handleKeyPress(event) {
            if (event.key === 'f' || event.key === 'F') {
                toggleFullScreen();
            }
        }

        // Initialize sizes based on screen dimensions
        function initializeSizes() {
            const minDimension = Math.min(window.innerWidth, window.innerHeight);
            SQUARE_SIZE = minDimension * 0.1;
            SUN_MARGIN = SQUARE_SIZE;
        }

        // Modify the resizeCanvas function to maintain positions
        function resizeCanvas() {
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Only reinitialize if dimensions actually changed
            if (oldWidth !== canvas.width || oldHeight !== canvas.height) {
                initializeSizes();
                if (currentLevel === 2 && level2Positions) {
                    // Update positions while maintaining relative positioning
                    level2Positions = level2Positions.map(pos => ({
                        x: (pos.x / oldWidth) * canvas.width,
                        y: (pos.y / oldHeight) * canvas.height
                    }));
                }
                repositionSquares(oldWidth, oldHeight);
            }
        }

        // Reposition squares while maintaining relative positions and colors
        function repositionSquares(oldWidth, oldHeight) {
            if (!squares.length) return;

            const widthRatio = canvas.width / oldWidth;
            const heightRatio = canvas.height / oldHeight;

            if (currentLevel === 2) {
                const positions = getFixedPositions();
                squares.forEach((square, index) => {
                    square.x = positions[index].x;
                    square.y = positions[index].y;
                });
            } else {
                squares.forEach(square => {
                    square.x = square.x * widthRatio;
                    square.y = square.y * heightRatio;
                });
            }
        }

        // Color adjustment helper
        function adjustColor(color, amount) {
            const hex = color.replace('#', '');
            const r = Math.max(0, Math.min(255, parseInt(hex.slice(0, 2), 16) + amount));
            const g = Math.max(0, Math.min(255, parseInt(hex.slice(2, 4), 16) + amount));
            const b = Math.max(0, Math.min(255, parseInt(hex.slice(4, 6), 16) + amount));
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        // Store level 2 positions when initialized
        let level2Positions = null;

        // Get fixed positions for level 2 with improved positioning and randomization
        function getFixedPositions() {
            // If positions are already set and we're not resetting the game, return existing positions
            if (level2Positions && gameActive) {
                return level2Positions;
            }

            // Use a similar approach to level 1 with random positions that don't overlap
            const selectedPositions = [];
            const minDistance = SQUARE_SIZE * 2.5; // Minimum distance between squares to avoid overlap
            const margin = SQUARE_SIZE * 2;
            const topMargin = SUN_MARGIN * 3;
            const availableWidth = canvas.width - 2 * margin - SQUARE_SIZE;
            const availableHeight = canvas.height - topMargin - margin - SQUARE_SIZE;

            // Generate 5 random positions with no overlap
            let attempts = 0;
            const maxAttempts = 500; // Increased max attempts to ensure we find valid positions

            // Helper function to check if a position overlaps with existing positions
            function checkPositionOverlap(pos, existingPositions) {
                // Check overlap with sun
                const maxClicks = LEVEL2_TRIALS;
                const sunX = 50 + (canvas.width - 100) * (sunPosition / maxClicks);
                const sunY = 30;
                const sunRadius = 40;

                const dxSun = pos.x - sunX;
                const dySun = pos.y - sunY;
                const distanceToSun = Math.sqrt(dxSun * dxSun + dySun * dySun);

                if (distanceToSun < (sunRadius + SQUARE_SIZE)) {
                    return true; // Overlaps with sun
                }

                // Check overlap with other squares
                for (const square of existingPositions) {
                    const dx = pos.x - square.x;
                    const dy = pos.y - square.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < minDistance) return true; // Overlaps with another square
                }

                return false; // No overlap
            }

            // Generate positions
            for (let i = 0; i < 5; i++) {
                let position;
                attempts = 0;

                do {
                    position = {
                        x: margin + Math.random() * availableWidth,
                        y: topMargin + Math.random() * availableHeight
                    };

                    attempts++;
                    if (attempts > maxAttempts) {
                        console.warn("Couldn't find non-overlapping positions, retrying with new positions");
                        selectedPositions.length = 0; // Clear current positions
                        i = -1; // Restart the loop
                        break;
                    }
                } while (checkPositionOverlap(position, selectedPositions));

                if (i >= 0) {
                    selectedPositions.push(position);
                }
            }

            // Store the positions for this level
            level2Positions = selectedPositions;
            return selectedPositions;
        }

        // Modified getRandomPosition function with improved bounds
        function getRandomPosition() {
            const margin = SQUARE_SIZE * 2;
            const topMargin = SUN_MARGIN * 3;
            const availableWidth = canvas.width - 2 * margin - SQUARE_SIZE;
            const availableHeight = canvas.height - topMargin - margin - SQUARE_SIZE;

            return {
                x: margin + Math.random() * availableWidth,
                y: topMargin + Math.random() * availableHeight
            };
        }

        // Modified checkOverlap function to include sun position check
        function checkOverlap(pos, existingSquares) {
            const minDistance = SQUARE_SIZE * 2.5;

            const maxClicks = MAX_CLICKS;
            const sunX = 50 + (canvas.width - 100) * (sunPosition / maxClicks);
            const sunY = 30;
            const sunRadius = 40;

            const dxSun = pos.x - sunX;
            const dySun = pos.y - sunY;
            const distanceToSun = Math.sqrt(dxSun * dxSun + dySun * dySun);

            if (distanceToSun < (sunRadius + SQUARE_SIZE)) {
                return true;
            }

            for (const square of existingSquares) {
                const dx = pos.x - square.x;
                const dy = pos.y - square.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < minDistance) return true;
            }
            return false;
        }


        // Initialize squares with improved positioning
        function initializeSquares() {
            squares = [];
            squareColors = [];

            if (currentLevel === 2) {
                const positions = getFixedPositions();
                const values = [1, 2, 3, 4, 5];

                for (let i = values.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [values[i], values[j]] = [values[j], values[i]];
                }

                positions.forEach((position, i) => {
                    const squareColor = COLORS[values[i] - 1];
                    squareColors.push(squareColor);

                    squares.push({
                        x: position.x,
                        y: position.y,
                        value: values[i],
                        points: values[i],
                        color: '#FFFFFF',
                        scale: 1,
                        isAnimating: false,
                        isRevealed: false
                    });
                });
            } else {
                const values = [1, 2, 3, 4, 5];

                for (let i = values.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [values[i], values[j]] = [values[j], values[i]];
                }

                for (let i = 0; i < 5; i++) {
                    let position;
                    let attempts = 0;
                    const maxAttempts = 100;

                    do {
                        position = getRandomPosition();
                        attempts++;
                        if (attempts > maxAttempts) {
                            squares = [];
                            squareColors = [];
                            i = -1;
                            break;
                        }
                    } while (checkOverlap(position, squares));

                    if (i >= 0) {
                        const squareColor = COLORS[values[i] - 1];
                        squareColors.push(squareColor);

                        squares.push({
                            x: position.x,
                            y: position.y,
                            value: values[i],
                            points: values[i],
                            color: currentLevel === 1 ? squareColor : '#FFFFFF',
                            scale: 1,
                            isAnimating: false,
                            isRevealed: false
                        });
                    }
                }
            }
        }

        // Draw sun
        function drawSun() {
            const maxClicks = getTrialCount(currentLevel);
            const sunX = 50 + (canvas.width - 100) * (sunPosition / maxClicks);

            // Draw sun implementation...
            const outerGradient = ctx.createRadialGradient(sunX, 30, 0, sunX, 30, 40);
            outerGradient.addColorStop(0, 'rgba(255, 255, 200, 0.4)');
            outerGradient.addColorStop(0.2, 'rgba(255, 200, 0, 0.2)');
            outerGradient.addColorStop(1, 'rgba(255, 150, 0, 0)');
            ctx.fillStyle = outerGradient;
            ctx.beginPath();
            ctx.arc(sunX, 30, 40, 0, Math.PI * 2);
            ctx.fill();

            const innerGradient = ctx.createRadialGradient(sunX, 30, 0, sunX, 30, 15);
            innerGradient.addColorStop(0, '#FFFFFF');
            innerGradient.addColorStop(0.3, '#FFFFA0');
            innerGradient.addColorStop(0.6, '#FFD700');
            innerGradient.addColorStop(1, '#FFA500');
            ctx.fillStyle = innerGradient;
            ctx.beginPath();
            ctx.arc(sunX, 30, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.arc(sunX - 3, 27, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Reveal animation
        function revealSquare(square) {
            if (square.isRevealing) return;

            square.isRevealing = true;
            const startTime = Date.now();
            const originalColor = square.color;
            const targetColor = squareColors[squares.indexOf(square)];

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(1, elapsed / REVEAL_ANIMATION_DURATION);

                const r1 = parseInt(originalColor.slice(1, 3), 16);
                const g1 = parseInt(originalColor.slice(3, 5), 16);
                const b1 = parseInt(originalColor.slice(5, 7), 16);

                const r2 = parseInt(targetColor.slice(1, 3), 16);
                const g2 = parseInt(targetColor.slice(3, 5), 16);
                const b2 = parseInt(targetColor.slice(5, 7), 16);

                const r = Math.round(r1 + (r2 - r1) * progress);
                const g = Math.round(g1 + (g2 - g1) * progress);
                const b = Math.round(b1 + (b2 - b1) * progress);

                square.color = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;

                square.scale = 1 + 0.2 * Math.sin(progress * Math.PI);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    square.color = targetColor;
                    square.scale = 1;
                    square.isRevealing = false;
                    square.isRevealed = true;
                    revealedSquares.add(squares.indexOf(square));

                    // Standard animation for Level 2
                }
            }

            animate();
        }

        // Draw square
        function drawSquare(square) {
            const size = SQUARE_SIZE * square.scale;
            const x = square.x - (size - SQUARE_SIZE) / 2;
            const y = square.y - (size - SQUARE_SIZE) / 2;

            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
            gradient.addColorStop(0, square.color);
            gradient.addColorStop(1, adjustColor(square.color, -20));
            ctx.fillStyle = gradient;

            ctx.beginPath();
            ctx.roundRect(x, y, size, size, 5);
            ctx.fill();

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        // Animate square with configurable parameters
        function animateSquare(square, options = {}) {
            if (square.isAnimating) return;

            // Default options
            const defaultOptions = {
                amplitude: 0.2,  // How much the square scales (0.2 = 20% larger)
                duration: ANIMATION_DURATION, // Animation duration in ms
                easing: Math.sin // Easing function to use
            };

            // Merge user options with defaults
            const config = {...defaultOptions, ...options};

            square.isAnimating = true;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / config.duration;

                if (progress < 0.5) {
                    // Scale up during first half
                    square.scale = 1 + config.amplitude * config.easing(progress * Math.PI);
                } else {
                    // Scale back down during second half
                    square.scale = 1 + config.amplitude * config.easing((1 - progress) * Math.PI);
                }

                if (progress >= 1) {
                    // Animation complete
                    square.scale = 1;
                    square.isAnimating = false;
                } else {
                    // Continue animation
                    requestAnimationFrame(animate);
                }
            }

            // Start animation
            animate();
        }

        // Main draw function
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (gameActive) {
                squares.forEach(drawSquare);
                drawSun();

                // Start reaction time timer if not already started
                if (clickStartTime === 0 && !isWaiting) {
                    startClickTimer();
                }


                // Draw level and try counter with updated format
                const playerId = localStorage.getItem('monkeyId');
                const tryNumberKey = playerId ? getUserTryNumberKey(playerId) : 'currentTryNumber';
                const currentTryNumber = parseInt(localStorage.getItem(tryNumberKey)) || 1;
                ctx.font = '20px Arial';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'left';
                ctx.fillText(`L-${currentLevel}:${currentTryNumber}`, 20, canvas.height - 20);
            }
        }

        // Update game score
        function updateGameScore(score) {
            let currentGame = JSON.parse(localStorage.getItem('currentGame')) || {
                level: currentLevel,
                trials: [],
                total: 0,
                inProgress: true
            };

            currentGame.trials.push(score);
            currentGame.total = currentGame.trials.reduce((sum, score) => sum + score, 0);
            currentGame.level = currentLevel;

            console.log(`ðŸ“ˆ Score updated: +${score} points. Trial ${currentGame.trials.length}/${getTrialCount(currentLevel)}. Total: ${currentGame.total}`);

            localStorage.setItem('currentGame', JSON.stringify(currentGame));
            localStorage.setItem('scoreUpdate', Date.now().toString());
        }

        function handleClick(event) {
            if (!gameActive || isWaiting) return;

            const rect = canvas.getBoundingClientRect();
            const x = (event.clientX - rect.left) * (canvas.width / rect.width);
            const y = (event.clientY - rect.top) * (canvas.height / rect.height);

            // Get the maximum clicks for the current level
            let maxClicks;
            if (currentLevel === 1) {
                maxClicks = MAX_CLICKS;  // Level 1: 10 trials
            } else if (currentLevel === 2) {
                maxClicks = LEVEL2_TRIALS;  // Level 2: 20 trials
            } else {
                maxClicks = MAX_CLICKS;  // Default fallback
            }

            squares.forEach((square, index) => {
                if (x >= square.x && x <= square.x + SQUARE_SIZE &&
                    y >= square.y && y <= square.y + SQUARE_SIZE) {

                    clicks++;
                    sunPosition = clicks;
                    isWaiting = true;

                    // Record reaction time
                    const reactionTime = recordClickDuration(square.tileId || `${square.tileX}_${square.tileY}`, clicks);
                    console.log(`Reaction time for trial ${clicks}: ${reactionTime.toFixed(2)}ms`);

                    let points = square.points;


                    // Play correct sound the number of times equal to points (always play regardless of pellet dispenser)
                    console.log(`Square clicked! Points: ${points}, calling playCorrectSound...`);
                    playCorrectSound(points);

                    // Call the pellet dispenser with the score value (non-blocking)
                    dispensePellets(points);

                    if (currentLevel === 1) {
                        // Level 1 uses standard animation (no reveal first)
                        animateSquare(square, {
                            amplitude: 0.2,   // Standard bounce (20% scale)
                            duration: ANIMATION_DURATION // Standard duration
                        });
                    } else if (currentLevel === 2) {
                        if (!square.isRevealed) {
                            // First reveal - just show the color
                            revealSquare(square);
                        } else {
                            // Already revealed tile - do a subtle bounce animation
                            animateSquare(square, {
                                amplitude: 0.1,   // Smaller bounce (10% scale)
                                duration: 150     // Faster animation
                            });
                        }
                    }

                    updateGameScore(points);

                    storeTrialData(points, square.tileX || 0, square.tileY || 0, 1);

                    // Save game state after each click
                    saveGameState();
                    saveTrialResult(points, clicks);

                    setTimeout(() => {
                        isWaiting = false;

                        // Check if we've completed all trials for the current level
                        const maxClicksToCheck = getTrialCount(currentLevel);

                        // Standard logic for all levels
                        if (clicks >= maxClicksToCheck) {
                            handleGameCompletion();
                        } else {
                            resetSquareAnimations();
                        }
                    }, ITI_DURATION);
                }
            });
        }

        // Modified handleGameCompletion function
        function handleGameCompletion() {
            console.log(`ðŸ Game completion triggered for Level ${currentLevel}`);
            gameActive = false;

            // Get current game data or create default
            let currentGame = JSON.parse(localStorage.getItem('currentGame')) || {
                level: currentLevel,
                trials: [],
                total: 0,
                inProgress: true
            };

            // Make sure we have trials data
            if (!currentGame.trials || currentGame.trials.length === 0) {
                console.warn('No trials data found, creating empty array');
                currentGame.trials = [];
            }

            // Calculate total score from trials
            const totalScore = currentGame.trials.reduce((sum, score) => sum + score, 0);
            console.log(`ðŸ“Š Level ${currentLevel} completed with score: ${totalScore}`);

            // Store level completion data
            storeLevelData(totalScore);

            // Save game session
            const playerId = localStorage.getItem('monkeyId');
            const tryNumberKey = playerId ? getUserTryNumberKey(playerId) : 'currentTryNumber';
            const gameSession = {
                monkeyId: playerId,
                level: currentLevel,
                trials: currentGame.trials,
                totalScore: totalScore,
                timestamp: new Date().toISOString(),
                tryNumber: parseInt(localStorage.getItem(tryNumberKey)) || 1
            };

            let allSessions = JSON.parse(localStorage.getItem('allGameSessions')) || [];
            allSessions.push(gameSession);
            localStorage.setItem('allGameSessions', JSON.stringify(allSessions));

            // Mark game as completed
            currentGame.inProgress = false;
            localStorage.setItem('currentGame', JSON.stringify(currentGame));

            // Clear all squares
            squares = [];

            // Determine next action based on level and score
            let nextAction = '';
            let advanceToLevel2 = false;
            let advanceToLevel3 = false;
            let retryCurrentLevel = false;

            if (currentLevel === 1) {
                if (totalScore >= MIN_SCORE_FOR_LEVEL2) {
                    // Passed Level 1 - advance to Level 2
                    nextAction = `ðŸŽ‰ Level 1 Complete!\nScore: ${totalScore}/${MIN_SCORE_FOR_LEVEL2}\n\nAdvancing to Level 2...`;
                    advanceToLevel2 = true;
                    console.log(`âœ… ADVANCING TO LEVEL 2! Score: ${totalScore} >= ${MIN_SCORE_FOR_LEVEL2}`);
                } else {
                    // Failed Level 1 - retry
                    const nextTry = (parseInt(localStorage.getItem(tryNumberKey)) || 1) + 1;
                    nextAction = `âŒ Level 1 Failed\nScore: ${totalScore}/${MIN_SCORE_FOR_LEVEL2}\n\nRetrying Level 1 (Try ${nextTry})...`;
                    retryCurrentLevel = true;
                    console.log(`âŒ RETRYING LEVEL 1! Score: ${totalScore} < ${MIN_SCORE_FOR_LEVEL2}`);
                }
            } else if (currentLevel === 2) {
                // Level 2 completed - check for Level 3 advancement
                if (totalScore >= MIN_SCORE_FOR_LEVEL3) {
                    // Qualified for Level 3 - redirect to testbrowser.html
                    nextAction = `ðŸŽ‰ Level 2 Complete!\nScore: ${totalScore}/${MIN_SCORE_FOR_LEVEL3}\n\nAdvancing to Level 3...`;
                    advanceToLevel3 = true;
                    console.log(`ðŸš€ ADVANCING TO LEVEL 3! Score: ${totalScore} >= ${MIN_SCORE_FOR_LEVEL3}`);
                } else {
                    // Failed Level 2 - restart Level 2
                    const nextTry = (parseInt(localStorage.getItem(tryNumberKey)) || 1) + 1;
                    nextAction = `âŒ Level 2 Failed\nScore: ${totalScore}/${MIN_SCORE_FOR_LEVEL3}\n\nRestarting Level 2 (Try ${nextTry})...`;
                    retryCurrentLevel = true;
                    console.log(`âŒ RESTARTING LEVEL 2! Score: ${totalScore} < ${MIN_SCORE_FOR_LEVEL3}`);
                }
            }

            // Show transition screen
            showTransitionScreen(nextAction);

            // Execute transition after delay
            setTimeout(() => {
                const playerId = localStorage.getItem('monkeyId');
                const tryNumberKey = playerId ? getUserTryNumberKey(playerId) : 'currentTryNumber';
                
                if (advanceToLevel2) {
                    currentLevel = 2;
                    clicks = 0; // Reset clicks for new level
                    localStorage.setItem(tryNumberKey, '1');
                    console.log(`ðŸŽ¯ SETTING LEVEL 2, TRY 1 for ${playerId}`);
                    // Clear previous game state since we're advancing
                    clearGameState();
                    resetGame();
                } else if (advanceToLevel3) {
                    // Advance to Level 3 - redirect to testbrowser.html
                    console.log(`ðŸš€ ADVANCING TO LEVEL 3 - Redirecting to testbrowser.html (Player: ${playerId})`);
                    // Clear ALL browser game state since player is now permanently Level 3
                    clearGameState();
                    if (playerId) {
                        localStorage.removeItem(`currentGame_${playerId}`);
                        localStorage.removeItem(`allGameSessions_${playerId}`);
                        localStorage.removeItem(tryNumberKey);
                    }
                    console.log(`ðŸ—‘ï¸ Cleared all Levels 1-2 data for ${playerId} - player is now permanently Level 3`);
                    advanceToLevel3Handler(totalScore);
                } else if (retryCurrentLevel) {
                    incrementTryNumber();
                    clicks = 0; // Reset clicks for retry
                    const newTryNumber = parseInt(localStorage.getItem(tryNumberKey)) || 1;
                    console.log(`ðŸ”„ Starting Level ${currentLevel}, Try ${newTryNumber} for ${playerId}`);
                    // Clear game state for fresh retry
                    clearGameState();
                    resetGame();
                }
                
                // Save the new state after transitions
                saveGameState();
            }, BLANK_SCREEN_DURATION);
        }

        // Function to show transition screen
        function showTransitionScreen(message) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = '32px Arial';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            
            const lines = message.split('\n');
            lines.forEach((line, index) => {
                ctx.fillText(line, canvas.width / 2, canvas.height / 2 - 50 + (index * 40));
            });
        }

        // Function to handle Level 3 advancement
        function advanceToLevel3Handler(level2Score) {
            const monkeyId = localStorage.getItem('monkeyId');
            
            // Mark player as permanently Level 3 - NEVER go back to Levels 1-2 (USER-SPECIFIC)
            const playerLevel3Key = `playerLevel3Status_${monkeyId}`;
            const qualificationKey = `level3QualificationTimestamp_${monkeyId}`;
            localStorage.setItem(playerLevel3Key, 'true');
            localStorage.setItem(qualificationKey, new Date().toISOString());
            
            // Store progression data for testbrowser.html
            const progressionData = {
                playerId: monkeyId,
                fromLevel: 2,
                level2Score: level2Score,
                level2Completed: true,
                advancedToLevel3: true,
                timestamp: new Date().toISOString()
            };
            
            // Store in localStorage for testbrowser.html to read
            localStorage.setItem('gameProgression', JSON.stringify(progressionData));
            localStorage.setItem('startLevel3', 'true');
            
            console.log('ðŸ“¦ Stored progression data:', progressionData);
            console.log('ðŸŽ¯ PLAYER NOW PERMANENTLY LEVEL 3 - Will only play Level 3 from now on');
            console.log('ðŸš€ Redirecting to Level 3 (testbrowser.html)...');
            
            // Redirect to testbrowser.html with parameters
            const params = new URLSearchParams({
                from: 'browser_game',
                playerId: monkeyId,
                level2Score: level2Score,
                startLevel: '3'
            });
            
            window.location.href = `testbrowser.html?${params.toString()}`;
        }

        // Function to increment try number for same level
        function incrementTryNumber() {
            const playerId = localStorage.getItem('monkeyId');
            if (!playerId) return;
            
            const tryNumberKey = getUserTryNumberKey(playerId);
            const currentTryNumber = parseInt(localStorage.getItem(tryNumberKey)) || 1;
            const newTryNumber = currentTryNumber + 1;
            localStorage.setItem(tryNumberKey, newTryNumber.toString());
            console.log(`ðŸ”„ Try number incremented to: ${newTryNumber} for Level ${currentLevel} (Player: ${playerId})`);
        }

        // Reset square animations
        function resetSquareAnimations() {
            squares.forEach(square => {
                square.scale = 1;
                square.isAnimating = false;
            });
        }

        // Improved resetGame function with cleaner transition between levels
        async function resetGame() {
            // Clear game state
            clicks = 0;
            sunPosition = 0;
            gameResults = [];
            gameActive = true;
            isWaiting = false;
            revealedSquares.clear();
            squares = []; // Ensure squares are cleared before initializing new ones
            squareColors = []; // Clear colors as well

            // Reset reaction time tracking
            clickStartTime = 0;
            clickDurations = {};

            const monkeyId = localStorage.getItem('monkeyId');

            // Keep current try number (don't reset it here - it's managed by level progression logic)


            // Reset level-specific data
            if (currentLevel === 2) {
                level2Positions = null; // Force regeneration of positions
            }


            // Create fresh game state in localStorage
            const currentTryNumber = parseInt(localStorage.getItem('currentTryNumber')) || 1;
            console.log(`ðŸŽ® Resetting game: Level ${currentLevel}, Try ${currentTryNumber}`);
            
            localStorage.setItem('currentGame', JSON.stringify({
                level: currentLevel,
                trials: [],
                total: 0,
                inProgress: true,
                tryNumber: currentTryNumber
            }));

            // Re-initialize sizes before creating squares
            initializeSizes();

            // Create new squares for this level
            initializeSquares();
            
            console.log(`âœ… Game reset complete: Level ${currentLevel}, Try ${currentTryNumber}`);

        }

        // Initialize game with improved setup
        async function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // Set initial dimensions to prevent resize issues
            lastScreenWidth = window.innerWidth;
            lastScreenHeight = window.innerHeight;

            // Initialize game canvas
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Clear the screen first to prevent flashing/merging
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Note: monkey's progress was already loaded in startGame()

            // Initialize sizes first
            initializeSizes();

            // Then reset the game (which will create squares)
            await resetGame();

            // Set up event listeners
            document.addEventListener('keydown', handleKeyPress);
            canvas.addEventListener('click', handleClick);
            window.addEventListener('resize', () => {
                // Only trigger resize if dimensions actually changed
                if (window.innerWidth !== lastScreenWidth || window.innerHeight !== lastScreenHeight) {
                    resizeCanvas();
                    lastScreenWidth = window.innerWidth;
                    lastScreenHeight = window.innerHeight;
                }
            });

            // Initialize audio on first user interaction
            initializeAudio();

            // Start animation loop
            function animate() {
                draw();
                requestAnimationFrame(animate);
            }
            animate();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            // Check for Ctrl+Shift+A or Cmd+Shift+A for Admin Panel
            if ((event.ctrlKey || event.metaKey) && event.shiftKey && (event.key === 'A' || event.key === 'a')) {
                window.location.href = 'browser_admin.html';
            }


            // Pellet configuration shortcut (Ctrl+Shift+P or Cmd+Shift+P)
            if ((event.ctrlKey || event.metaKey) && event.shiftKey && (event.key === 'P' || event.key === 'p')) {
                event.preventDefault(); // Prevent browser print dialog
                showPelletConfig();
            }
        });
    </script>
</body>
</html>